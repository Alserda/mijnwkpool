<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
    <title>jquery_tablesorter_js.html</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <link rel="stylesheet" href="../../../../../../../../css/reset.css" type="text/css" media="screen" />
<link rel="stylesheet" href="../../../../../../../../css/main.css" type="text/css" media="screen" />
<link rel="stylesheet" href="../../../../../../../../css/github.css" type="text/css" media="screen" />
<script src="../../../../../../../../js/jquery-1.3.2.min.js" type="text/javascript" charset="utf-8"></script>
<script src="../../../../../../../../js/jquery-effect.js" type="text/javascript" charset="utf-8"></script>
<script src="../../../../../../../../js/main.js" type="text/javascript" charset="utf-8"></script>
<script src="../../../../../../../../js/highlight.pack.js" type="text/javascript" charset="utf-8"></script>

</head>

<body>     
    <div class="banner">
        
        <h1>
            jquery_tablesorter_js.html
        </h1>
        <ul class="files">
            <li>doc/rails/files/app/assets/javascripts/vendor/jquery_tablesorter_js.html</li>
            <li>Last modified: 2014-06-16 15:53:37 +0200</li>
        </ul>
    </div>

    <div id="bodyContent">
        <div id="content">
  
    <div class="description">
      
<p>&lt;!DOCTYPE html PUBLIC “-//W3C//DTD XHTML 1.0 Transitional//EN”</p>

<pre><code>&quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;</code></pre>

<p>&lt;html xmlns=“<a
href="http://www.w3.org/1999/xhtml">www.w3.org/1999/xhtml</a>”
xml:lang=“en” lang=“en”&gt; &lt;head&gt;</p>

<pre><code>&lt;title&gt;jquery.tablesorter.js&lt;/title&gt;
&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot; /&gt;
&lt;link rel=&quot;stylesheet&quot; href=&quot;../../../../../css/reset.css&quot; type=&quot;text/css&quot; media=&quot;screen&quot; /&gt;</code></pre>

<p>&lt;link rel=“stylesheet” href=“../../../../../css/main.css”
type=“text/css” media=“screen” /&gt; &lt;link rel=“stylesheet”
href=“../../../../../css/github.css” type=“text/css” media=“screen” /&gt;
&lt;script src=“../../../../../js/jquery-1.3.2.min.js”
type=“text/javascript” charset=“utf-8”&gt;&lt;/script&gt; &lt;script
src=“../../../../../js/jquery-effect.js” type=“text/javascript”
charset=“utf-8”&gt;&lt;/script&gt; &lt;script
src=“../../../../../js/main.js” type=“text/javascript”
charset=“utf-8”&gt;&lt;/script&gt; &lt;script
src=“../../../../../js/highlight.pack.js” type=“text/javascript”
charset=“utf-8”&gt;&lt;/script&gt;</p>

<p>&lt;/head&gt;</p>

<p>&lt;body&gt;</p>

<pre><code>&lt;div class=&quot;banner&quot;&gt;

    &lt;h1&gt;
        jquery.tablesorter.js
    &lt;/h1&gt;
    &lt;ul class=&quot;files&quot;&gt;
        &lt;li&gt;app/assets/javascripts/vendor/jquery.tablesorter.js&lt;/li&gt;
        &lt;li&gt;Last modified: 2014-06-10 17:47:16 +0200&lt;/li&gt;
    &lt;/ul&gt;
&lt;/div&gt;

&lt;div id=&quot;bodyContent&quot;&gt;
    &lt;div id=&quot;content&quot;&gt;

&lt;div class=&quot;description&quot;&gt;</code></pre>

<p>&lt;p&gt;(function ($) {&lt;/p&gt;</p>

<p>&lt;pre&gt;&lt;code&gt;$.extend({</p>

<pre><code>tablesorter: new
function () {

    var parsers = [],
        widgets = [];

    this.defaults = {
        cssHeader: &amp;quot;header&amp;quot;,
        cssAsc: &amp;quot;headerSortUp&amp;quot;,
        cssDesc: &amp;quot;headerSortDown&amp;quot;,
        cssChildRow: &amp;quot;expand-child&amp;quot;,
        sortInitialOrder: &amp;quot;asc&amp;quot;,
        sortMultiSortKey: &amp;quot;shiftKey&amp;quot;,
        sortForce: null,
        sortAppend: null,
        sortLocaleCompare: true,
        textExtraction: &amp;quot;simple&amp;quot;,
        parsers: {}, widgets: [],
        widgetZebra: {
            css: [&amp;quot;even&amp;quot;, &amp;quot;odd&amp;quot;]
        }, headers: {}, widthFixed: false,
        cancelSelection: true,
        sortList: [],
        headerList: [],
        dateFormat: &amp;quot;eu&amp;quot;,
        decimal: &amp;#39;/\.|\,/g&amp;#39;,
        onRenderHeader: null,
        selectorHeaders: &amp;#39;thead th&amp;#39;,
        debug: false
    };

       debuging utils   

    function benchmark(s, d) {
        log(s + &amp;quot;,&amp;quot; + (new Date().getTime() - d.getTime()) + &amp;quot;ms&amp;quot;);
    }

    this.benchmark = benchmark;

    function log(s) {
        if (typeof console != &amp;quot;undefined&amp;quot; &amp;amp;&amp;amp; typeof console.debug != &amp;quot;undefined&amp;quot;) {
            console.log(s);
        } else {
            alert(s);
        }
    }

       parsers utils   

    function buildParserCache(table, $headers) {

        if (table.config.debug) {
            var parsersDebug = &amp;quot;&amp;quot;;
        }

        if (table.tBodies.length == 0) return; // In the case of empty tables
        var rows = table.tBodies[0].rows;

        if (rows[0]) {

            var list = [],
                cells = rows[0].cells,
                l = cells.length;

            for (var i = 0; i &amp;lt; l; i++) {

                var p = false;

                if ($.metadata &amp;amp;&amp;amp; ($($headers[i]).metadata() &amp;amp;&amp;amp; $($headers[i]).metadata().sorter)) {

                    p = getParserById($($headers[i]).metadata().sorter);

                } else if ((table.config.headers[i] &amp;amp;&amp;amp; table.config.headers[i].sorter)) {

                    p = getParserById(table.config.headers[i].sorter);
                }
                if (!p) {

                    p = detectParserForColumn(table, rows, -1, i);
                }

                if (table.config.debug) {
                    parsersDebug += &amp;quot;column:&amp;quot; + i + &amp;quot; parser:&amp;quot; + p.id + &amp;quot;\n&amp;quot;;
                }

                list.push(p);
            }
        }

        if (table.config.debug) {
            log(parsersDebug);
        }

        return list;
    };

    function detectParserForColumn(table, rows, rowIndex, cellIndex) {
        var l = parsers.length,
            node = false,
            nodeValue = false,
            keepLooking = true;
        while (nodeValue == &amp;#39;&amp;#39; &amp;amp;&amp;amp; keepLooking) {
            rowIndex++;
            if (rows[rowIndex]) {
                node = getNodeFromRowAndCellIndex(rows, rowIndex, cellIndex);
                nodeValue = trimAndGetNodeText(table.config, node);
                if (table.config.debug) {
                    log(&amp;#39;Checking if value was empty on row:&amp;#39; + rowIndex);
                }
            } else {
                keepLooking = false;
            }
        }
        for (var i = 1; i &amp;lt; l; i++) {
            if (parsers[i].is(nodeValue, table, node)) {
                return parsers[i];
            }
        }
        // 0 is always the generic parser (text)
        return parsers[0];
    }

    function getNodeFromRowAndCellIndex(rows, rowIndex, cellIndex) {
        return rows[rowIndex].cells[cellIndex];
    }

    function trimAndGetNodeText(config, node) {
        return $.trim(getElementText(config, node));
    }

    function getParserById(name) {
        var l = parsers.length;
        for (var i = 0; i &amp;lt; l; i++) {
            if (parsers[i].id.toLowerCase() == name.toLowerCase()) {
                return parsers[i];
            }
        }
        return false;
    }

       utils   

    function buildCache(table) {

        if (table.config.debug) {
            var cacheTime = new Date();
        }

        var totalRows = (table.tBodies[0] &amp;amp;&amp;amp; table.tBodies[0].rows.length) || 0,
            totalCells = (table.tBodies[0].rows[0] &amp;amp;&amp;amp; table.tBodies[0].rows[0].cells.length) || 0,
            parsers = table.config.parsers,
            cache = {
                row: [],
                normalized: []
            };

        for (var i = 0; i &amp;lt; totalRows; ++i) {

                Add the table data to main data array   
            var c = $(table.tBodies[0].rows[i]),
                cols = [];

            // if this is a child row, add it to the last row&amp;#39;s children and
            // continue to the next row
            if (c.hasClass(table.config.cssChildRow)) {
                cache.row[cache.row.length - 1] = cache.row[cache.row.length - 1].add(c);
                // go to the next for loop
                continue;
            }

            cache.row.push(c);

            for (var j = 0; j &amp;lt; totalCells; ++j) {
                cols.push(parsers[j].format(getElementText(table.config, c[0].cells[j]), table, c[0].cells[j]));
            }

            cols.push(cache.normalized.length); // add position for rowCache
            cache.normalized.push(cols);
            cols = null;
        };

        if (table.config.debug) {
            benchmark(&amp;quot;Building cache for &amp;quot; + totalRows + &amp;quot; rows:&amp;quot;, cacheTime);
        }

        return cache;
    };

    function getElementText(config, node) {

        var text = &amp;quot;&amp;quot;;

        if (!node) return &amp;quot;&amp;quot;;

        if (!config.supportsTextContent) config.supportsTextContent = node.textContent || false;

        if (config.textExtraction == &amp;quot;simple&amp;quot;) {
            if (config.supportsTextContent) {
                text = node.textContent;
            } else {
                if (node.childNodes[0] &amp;amp;&amp;amp; node.childNodes[0].hasChildNodes()) {
                    text = node.childNodes[0].innerHTML;
                } else {
                    text = node.innerHTML;
                }
            }
        } else {
            if (typeof(config.textExtraction) == &amp;quot;function&amp;quot;) {
                text = config.textExtraction(node);
            } else {
                text = $(node).text();
            }
        }
        return text;
    }

    function appendToTable(table, cache) {

        if (table.config.debug) {
            var appendTime = new Date()
        }

        var c = cache,
            r = c.row,
            n = c.normalized,
            totalRows = n.length,
            checkCell = (n[0].length - 1),
            tableBody = $(table.tBodies[0]),
            rows = [];

        for (var i = 0; i &amp;lt; totalRows; i++) {
            var pos = n[i][checkCell];

            rows.push(r[pos]);

            if (!table.config.appender) {

                //var o = ;
                var l = r[pos].length;
                for (var j = 0; j &amp;lt; l; j++) {
                    tableBody[0].appendChild(r[pos][j]);
                }

                // 
            }
        }

        if (table.config.appender) {

            table.config.appender(table, rows);
        }

        rows = null;

        if (table.config.debug) {
            benchmark(&amp;quot;Rebuilt table:&amp;quot;, appendTime);
        }

        // apply table widgets
        applyWidget(table);

        // trigger sortend
        setTimeout(function () {
            $(table).trigger(&amp;quot;sortEnd&amp;quot;);
        }, 0);

    };

    function buildHeaders(table) {

        if (table.config.debug) {
            var time = new Date();
        }

        var meta = ($.metadata) ? true : false;

        var header_index = computeTableHeaderCellIndexes(table);

        $tableHeaders = $(table.config.selectorHeaders, table).each(function (index) {

            this.column = header_index[this.parentNode.rowIndex + &amp;quot;-&amp;quot; + this.cellIndex];
            // this.column = index;
            this.order = formatSortingOrder(table.config.sortInitialOrder);

                                this.count = this.order;

            if (checkHeaderMetadata(this) || checkHeaderOptions(table, index)) this.sortDisabled = true;
                                if (checkHeaderOptionsSortingLocked(table, index)) this.order = this.lockedOrder = checkHeaderOptionsSortingLocked(table, index);

            if (!this.sortDisabled) {
                var $th = $(this).addClass(table.config.cssHeader);
                if (table.config.onRenderHeader) table.config.onRenderHeader.apply($th);
            }

            // add cell to headerList
            table.config.headerList[index] = this;
        });

        if (table.config.debug) {
            benchmark(&amp;quot;Built headers:&amp;quot;, time);
            log($tableHeaders);
        }

        return $tableHeaders;

    };

    // from:
    // http://www.javascripttoolbox.com/lib/table/examples.php
    // http://www.javascripttoolbox.com/temp/table_cellindex.html

    function computeTableHeaderCellIndexes(t) {
        var matrix = [];
        var lookup = {};
        var thead = t.getElementsByTagName(&amp;#39;THEAD&amp;#39;)[0];
        var trs = thead.getElementsByTagName(&amp;#39;TR&amp;#39;);

        for (var i = 0; i &amp;lt; trs.length; i++) {
            var cells = trs[i].cells;
            for (var j = 0; j &amp;lt; cells.length; j++) {
                var c = cells[j];

                var rowIndex = c.parentNode.rowIndex;
                var cellId = rowIndex + &amp;quot;-&amp;quot; + c.cellIndex;
                var rowSpan = c.rowSpan || 1;
                var colSpan = c.colSpan || 1
                var firstAvailCol;
                if (typeof(matrix[rowIndex]) == &amp;quot;undefined&amp;quot;) {
                    matrix[rowIndex] = [];
                }
                // Find first available column in the first row
                for (var k = 0; k &amp;lt; matrix[rowIndex].length + 1; k++) {
                    if (typeof(matrix[rowIndex][k]) == &amp;quot;undefined&amp;quot;) {
                        firstAvailCol = k;
                        break;
                    }
                }
                lookup[cellId] = firstAvailCol;
                for (var k = rowIndex; k &amp;lt; rowIndex + rowSpan; k++) {
                    if (typeof(matrix[k]) == &amp;quot;undefined&amp;quot;) {
                        matrix[k] = [];
                    }
                    var matrixrow = matrix[k];
                    for (var l = firstAvailCol; l &amp;lt; firstAvailCol + colSpan; l++) {
                        matrixrow[l] = &amp;quot;x&amp;quot;;
                    }
                }
            }
        }
        return lookup;
    }

    function checkCellColSpan(table, rows, row) {
        var arr = [],
            r = table.tHead.rows,
            c = r[row].cells;

        for (var i = 0; i &amp;lt; c.length; i++) {
            var cell = c[i];

            if (cell.colSpan &amp;gt; 1) {
                arr = arr.concat(checkCellColSpan(table, headerArr, row++));
            } else {
                if (table.tHead.length == 1 || (cell.rowSpan &amp;gt; 1 || !r[row + 1])) {
                    arr.push(cell);
                }
                // headerArr[row] = (i+row);
            }
        }
        return arr;
    };

    function checkHeaderMetadata(cell) {
        if (($.metadata) &amp;amp;&amp;amp; ($(cell).metadata().sorter === false)) {
            return true;
        };
        return false;
    }

    function checkHeaderOptions(table, i) {
        if ((table.config.headers[i]) &amp;amp;&amp;amp; (table.config.headers[i].sorter === false)) {
            return true;
        };
        return false;
    }

                 function checkHeaderOptionsSortingLocked(table, i) {
        if ((table.config.headers[i]) &amp;amp;&amp;amp; (table.config.headers[i].lockedOrder)) return table.config.headers[i].lockedOrder;
        return false;
    }

    function applyWidget(table) {
        var c = table.config.widgets;
        var l = c.length;
        for (var i = 0; i &amp;lt; l; i++) {

            getWidgetById(c[i]).format(table);
        }

    }

    function getWidgetById(name) {
        var l = widgets.length;
        for (var i = 0; i &amp;lt; l; i++) {
            if (widgets[i].id.toLowerCase() == name.toLowerCase()) {
                return widgets[i];
            }
        }
    };

    function formatSortingOrder(v) {
        if (typeof(v) != &amp;quot;Number&amp;quot;) {
            return (v.toLowerCase() == &amp;quot;desc&amp;quot;) ? 1 : 0;
        } else {
            return (v == 1) ? 1 : 0;
        }
    }

    function isValueInArray(v, a) {
        var l = a.length;
        for (var i = 0; i &amp;lt; l; i++) {
            if (a[i][0] == v) {
                return true;
            }
        }
        return false;
    }

    function setHeadersCss(table, $headers, list, css) {
        // remove all header information
        $headers.removeClass(css[0]).removeClass(css[1]);

        var h = [];
        $headers.each(function (offset) {
            if (!this.sortDisabled) {
                h[this.column] = $(this);
            }
        });

        var l = list.length;
        for (var i = 0; i &amp;lt; l; i++) {
            h[list[i][0]].addClass(css[list[i][1]]);
        }
    }

    function fixColumnWidth(table, $headers) {
        var c = table.config;
        if (c.widthFixed) {
            var colgroup = $(&amp;#39;&amp;lt;colgroup&amp;gt;&amp;#39;);
            $(&amp;quot;tr:first td&amp;quot;, table.tBodies[0]).each(function () {
                colgroup.append($(&amp;#39;&amp;lt;col&amp;gt;&amp;#39;).css(&amp;#39;width&amp;#39;, $(this).width()));
            });
            $(table).prepend(colgroup);
        };
    }

    function updateHeaderSortCount(table, sortList) {
        var c = table.config,
            l = sortList.length;
        for (var i = 0; i &amp;lt; l; i++) {
            var s = sortList[i],
                o = c.headerList[s[0]];
            o.count = s[1];
            o.count++;
        }
    }

    /* sorting methods */

    function multisort(table, sortList, cache) {

        if (table.config.debug) {
            var sortTime = new Date();
        }

        var dynamicExp = &amp;quot;var sortWrapper = function(a,b) {&amp;quot;,
            l = sortList.length;

        // TODO: inline functions.
        for (var i = 0; i &amp;lt; l; i++) {

            var c = sortList[i][0];
            var order = sortList[i][1];
            // var s = (getCachedSortType(table.config.parsers,c) == &amp;quot;text&amp;quot;) ?
            // ((order == 0) ? &amp;quot;sortText&amp;quot; : &amp;quot;sortTextDesc&amp;quot;) : ((order == 0) ?
            // &amp;quot;sortNumeric&amp;quot; : &amp;quot;sortNumericDesc&amp;quot;);
            // var s = (table.config.parsers[c].type == &amp;quot;text&amp;quot;) ? ((order == 0)
            // ? makeSortText(c) : makeSortTextDesc(c)) : ((order == 0) ?
            // makeSortNumeric(c) : makeSortNumericDesc(c));
            var s = (table.config.parsers[c].type == &amp;quot;text&amp;quot;) ? ((order == 0) ? makeSortFunction(&amp;quot;text&amp;quot;, &amp;quot;asc&amp;quot;, c) : makeSortFunction(&amp;quot;text&amp;quot;, &amp;quot;desc&amp;quot;, c)) : ((order == 0) ? makeSortFunction(&amp;quot;numeric&amp;quot;, &amp;quot;asc&amp;quot;, c) : makeSortFunction(&amp;quot;numeric&amp;quot;, &amp;quot;desc&amp;quot;, c));
            var e = &amp;quot;e&amp;quot; + i;

            dynamicExp += &amp;quot;var &amp;quot; + e + &amp;quot; = &amp;quot; + s; // + &amp;quot;(a[&amp;quot; + c + &amp;quot;],b[&amp;quot; + c
            // + &amp;quot;]); &amp;quot;;
            dynamicExp += &amp;quot;if(&amp;quot; + e + &amp;quot;) { return &amp;quot; + e + &amp;quot;; } &amp;quot;;
            dynamicExp += &amp;quot;else { &amp;quot;;

        }

        // if value is the same keep orignal order
        var orgOrderCol = cache.normalized[0].length - 1;
        dynamicExp += &amp;quot;return a[&amp;quot; + orgOrderCol + &amp;quot;]-b[&amp;quot; + orgOrderCol + &amp;quot;];&amp;quot;;

        for (var i = 0; i &amp;lt; l; i++) {
            dynamicExp += &amp;quot;}; &amp;quot;;
        }

        dynamicExp += &amp;quot;return 0; &amp;quot;;
        dynamicExp += &amp;quot;}; &amp;quot;;

        if (table.config.debug) {
            benchmark(&amp;quot;Evaling expression:&amp;quot; + dynamicExp, new Date());
        }

        eval(dynamicExp);

        cache.normalized.sort(sortWrapper);

        if (table.config.debug) {
            benchmark(&amp;quot;Sorting on &amp;quot; + sortList.toString() + &amp;quot; and dir &amp;quot; + order + &amp;quot; time:&amp;quot;, sortTime);
        }

        return cache;
    };

    function makeSortFunction(type, direction, index) {
        var a = &amp;quot;a[&amp;quot; + index + &amp;quot;]&amp;quot;,
            b = &amp;quot;b[&amp;quot; + index + &amp;quot;]&amp;quot;;
        if (type == &amp;#39;text&amp;#39; &amp;amp;&amp;amp; direction == &amp;#39;asc&amp;#39;) {
            return &amp;quot;(&amp;quot; + a + &amp;quot; == &amp;quot; + b + &amp;quot; ? 0 : (&amp;quot; + a + &amp;quot; === null ? Number.POSITIVE_INFINITY : (&amp;quot; + b + &amp;quot; === null ? Number.NEGATIVE_INFINITY : (&amp;quot; + a + &amp;quot; &amp;lt; &amp;quot; + b + &amp;quot;) ? -1 : 1 )));&amp;quot;;
        } else if (type == &amp;#39;text&amp;#39; &amp;amp;&amp;amp; direction == &amp;#39;desc&amp;#39;) {
            return &amp;quot;(&amp;quot; + a + &amp;quot; == &amp;quot; + b + &amp;quot; ? 0 : (&amp;quot; + a + &amp;quot; === null ? Number.POSITIVE_INFINITY : (&amp;quot; + b + &amp;quot; === null ? Number.NEGATIVE_INFINITY : (&amp;quot; + b + &amp;quot; &amp;lt; &amp;quot; + a + &amp;quot;) ? -1 : 1 )));&amp;quot;;
        } else if (type == &amp;#39;numeric&amp;#39; &amp;amp;&amp;amp; direction == &amp;#39;asc&amp;#39;) {
            return &amp;quot;(&amp;quot; + a + &amp;quot; === null &amp;amp;&amp;amp; &amp;quot; + b + &amp;quot; === null) ? 0 :(&amp;quot; + a + &amp;quot; === null ? Number.POSITIVE_INFINITY : (&amp;quot; + b + &amp;quot; === null ? Number.NEGATIVE_INFINITY : &amp;quot; + a + &amp;quot; - &amp;quot; + b + &amp;quot;));&amp;quot;;
        } else if (type == &amp;#39;numeric&amp;#39; &amp;amp;&amp;amp; direction == &amp;#39;desc&amp;#39;) {
            return &amp;quot;(&amp;quot; + a + &amp;quot; === null &amp;amp;&amp;amp; &amp;quot; + b + &amp;quot; === null) ? 0 :(&amp;quot; + a + &amp;quot; === null ? Number.POSITIVE_INFINITY : (&amp;quot; + b + &amp;quot; === null ? Number.NEGATIVE_INFINITY : &amp;quot; + b + &amp;quot; - &amp;quot; + a + &amp;quot;));&amp;quot;;
        }
    };

    function makeSortText(i) {
        return &amp;quot;((a[&amp;quot; + i + &amp;quot;] &amp;lt; b[&amp;quot; + i + &amp;quot;]) ? -1 : ((a[&amp;quot; + i + &amp;quot;] &amp;gt; b[&amp;quot; + i + &amp;quot;]) ? 1 : 0));&amp;quot;;
    };

    function makeSortTextDesc(i) {
        return &amp;quot;((b[&amp;quot; + i + &amp;quot;] &amp;lt; a[&amp;quot; + i + &amp;quot;]) ? -1 : ((b[&amp;quot; + i + &amp;quot;] &amp;gt; a[&amp;quot; + i + &amp;quot;]) ? 1 : 0));&amp;quot;;
    };

    function makeSortNumeric(i) {
        return &amp;quot;a[&amp;quot; + i + &amp;quot;]-b[&amp;quot; + i + &amp;quot;];&amp;quot;;
    };

    function makeSortNumericDesc(i) {
        return &amp;quot;b[&amp;quot; + i + &amp;quot;]-a[&amp;quot; + i + &amp;quot;];&amp;quot;;
    };

    function sortText(a, b) {
        if (table.config.sortLocaleCompare) return a.localeCompare(b);
        return ((a &amp;lt; b) ? -1 : ((a &amp;gt; b) ? 1 : 0));
    };

    function sortTextDesc(a, b) {
        if (table.config.sortLocaleCompare) return b.localeCompare(a);
        return ((b &amp;lt; a) ? -1 : ((b &amp;gt; a) ? 1 : 0));
    };

    function sortNumeric(a, b) {
        return a - b;
    };

    function sortNumericDesc(a, b) {
        return b - a;
    };

    function getCachedSortType(parsers, i) {
        return parsers[i].type;
    }; /* public methods */
    this.construct = function (settings) {
        return this.each(function () {
            // if no thead or tbody quit.
            if (!this.tHead || !this.tBodies) return;
            // declare
            var $this, $document, $headers, cache, config, shiftDown = 0,
                sortOrder;
            // new blank config object
            this.config = {};
            // merge and extend.
            config = $.extend(this.config, $.tablesorter.defaults, settings);
            // store common expression for speed
            $this = $(this);
            // save the settings where they read
            $.data(this, &amp;quot;tablesorter&amp;quot;, config);
            // build headers
            $headers = buildHeaders(this);
            // try to auto detect column type, and store in tables config
            this.config.parsers = buildParserCache(this, $headers);
            // build the cache for the tbody cells
            cache = buildCache(this);
            // get the css class names, could be done else where.
            var sortCSS = [config.cssDesc, config.cssAsc];
            // fixate columns if the users supplies the fixedWidth option
            fixColumnWidth(this);
            // apply event handling to headers
            // this is to big, perhaps break it out?
            $headers.click(

            function (e) {
                var totalRows = ($this[0].tBodies[0] &amp;amp;&amp;amp; $this[0].tBodies[0].rows.length) || 0;
                if (!this.sortDisabled &amp;amp;&amp;amp; totalRows &amp;gt; 0) {
                    // Only call sortStart if sorting is
                    // enabled.
                    $this.trigger(&amp;quot;sortStart&amp;quot;);
                    // store exp, for speed
                    var $cell = $(this);
                    // get current column index
                    var i = this.column;
                    // get current column sort order
                    this.order = this.count++ % 2;
                                                // always sort on the locked order.
                                                if(this.lockedOrder) this.order = this.lockedOrder;

                                                // user only whants to sort on one
                    // column
                    if (!e[config.sortMultiSortKey]) {
                        // flush the sort list
                        config.sortList = [];
                        if (config.sortForce != null) {
                            var a = config.sortForce;
                            for (var j = 0; j &amp;lt; a.length; j++) {
                                if (a[j][0] != i) {
                                    config.sortList.push(a[j]);
                                }
                            }
                        }
                        // add column to sort list
                        config.sortList.push([i, this.order]);
                        // multi column sorting
                    } else {
                        // the user has clicked on an all
                        // ready sortet column.
                        if (isValueInArray(i, config.sortList)) {
                            // revers the sorting direction
                            // for all tables.
                            for (var j = 0; j &amp;lt; config.sortList.length; j++) {
                                var s = config.sortList[j],
                                    o = config.headerList[s[0]];
                                if (s[0] == i) {
                                    o.count = s[1];
                                    o.count++;
                                    s[1] = o.count % 2;
                                }
                            }
                        } else {
                            // add column to sort list array
                            config.sortList.push([i, this.order]);
                        }
                    };
                    setTimeout(function () {
                        // set css for headers
                        setHeadersCss($this[0], $headers, config.sortList, sortCSS);
                        appendToTable(
                                $this[0], multisort(
                                $this[0], config.sortList, cache)
                                                        );
                    }, 1);
                    // stop normal event by returning false
                    return false;
                }
                // cancel selection
            }).mousedown(function () {
                if (config.cancelSelection) {
                    this.onselectstart = function () {
                        return false
                    };
                    return false;
                }
            });
            // apply easy methods that trigger binded events
            $this.bind(&amp;quot;update&amp;quot;, function () {
                var me = this;
                setTimeout(function () {
                    // rebuild parsers.
                    me.config.parsers = buildParserCache(
                    me, $headers);
                    // rebuild the cache map
                    cache = buildCache(me);
                }, 1);
            }).bind(&amp;quot;updateCell&amp;quot;, function (e, cell) {
                var config = this.config;
                // get position from the dom.
                var pos = [(cell.parentNode.rowIndex - 1), cell.cellIndex];
                // update cache
                cache.normalized[pos[0]][pos[1]] = config.parsers[pos[1]].format(
                getElementText(config, cell), cell);
            }).bind(&amp;quot;sorton&amp;quot;, function (e, list) {
                $(this).trigger(&amp;quot;sortStart&amp;quot;);
                config.sortList = list;
                // update and store the sortlist
                var sortList = config.sortList;
                // update header count index
                updateHeaderSortCount(this, sortList);
                // set css for headers
                setHeadersCss(this, $headers, sortList, sortCSS);
                // sort the table and append it to the dom
                appendToTable(this, multisort(this, sortList, cache));
            }).bind(&amp;quot;appendCache&amp;quot;, function () {
                appendToTable(this, cache);
            }).bind(&amp;quot;applyWidgetId&amp;quot;, function (e, id) {
                getWidgetById(id).format(this);
            }).bind(&amp;quot;applyWidgets&amp;quot;, function () {
                // apply widgets
                applyWidget(this);
            });
            if ($.metadata &amp;amp;&amp;amp; ($(this).metadata() &amp;amp;&amp;amp; $(this).metadata().sortlist)) {
                config.sortList = $(this).metadata().sortlist;
            }
            // if user has supplied a sort list to constructor.
            if (config.sortList.length &amp;gt; 0) {
                $this.trigger(&amp;quot;sorton&amp;quot;, [config.sortList]);
            }
            // apply widgets
            applyWidget(this);
        });
    };
    this.addParser = function (parser) {
        var l = parsers.length,
            a = true;
        for (var i = 0; i &amp;lt; l; i++) {
            if (parsers[i].id.toLowerCase() == parser.id.toLowerCase()) {
                a = false;
            }
        }
        if (a) {
            parsers.push(parser);
        };
    };
    this.addWidget = function (widget) {
        widgets.push(widget);
    };
    this.formatFloat = function (s) {
        var i = parseFloat(s);
        return (isNaN(i)) ? 0 : i;
    };
    this.formatInt = function (s) {
        var i = parseInt(s);
        return (isNaN(i)) ? 0 : i;
    };
    this.isDigit = function (s, config) {
        // replace all an wanted chars and match.
        return /^[-+]?\d*$/.test($.trim(s.replace(/[,.&amp;#39;]/g, &amp;#39;&amp;#39;)));
    };
    this.clearTableBody = function (table) {
        if ($.browser.msie) {
            function empty() {
                while (this.firstChild)
                this.removeChild(this.firstChild);
            }
            empty.apply(table.tBodies[0]);
        } else {
            table.tBodies[0].innerHTML = &amp;quot;&amp;quot;;
        }
    };
}
</code></pre>

<p>});</p>

<p>// extend plugin scope $.fn.extend({</p>

<pre><code>tablesorter: $.tablesorter.construct</code></pre>

<p>});</p>

<p>// make shortcut var ts = $.tablesorter;</p>

<p>// add default parsers ts.addParser({</p>

<pre><code>id: &amp;quot;text&amp;quot;,
is: function (s) {
    return true;
}, format: function (s) {
    return $.trim(s.toLocaleLowerCase());
}, type: &amp;quot;text&amp;quot;</code></pre>

<p>});</p>

<p>ts.addParser({</p>

<pre><code>id: &amp;quot;digit&amp;quot;,
is: function (s, table) {
    var c = table.config;
    return $.tablesorter.isDigit(s, c);
}, format: function (s) {
    return $.tablesorter.formatFloat(s);
}, type: &amp;quot;numeric&amp;quot;</code></pre>

<p>});</p>

<p>ts.addParser({</p>

<pre><code>id: &amp;quot;currency&amp;quot;,
is: function (s) {
    return /^[£$€?.]/.test(s);
}, format: function (s) {
    return $.tablesorter.formatFloat(s.replace(new RegExp(/[£$€]/g), &amp;quot;&amp;quot;));
}, type: &amp;quot;numeric&amp;quot;</code></pre>

<p>});</p>

<p>ts.addParser({</p>

<pre><code>id: &amp;quot;ipAddress&amp;quot;,
is: function (s) {
    return /^\d{2,3}[\.]\d{2,3}[\.]\d{2,3}[\.]\d{2,3}$/.test(s);
}, format: function (s) {
    var a = s.split(&amp;quot;.&amp;quot;),
        r = &amp;quot;&amp;quot;,
        l = a.length;
    for (var i = 0; i &amp;lt; l; i++) {
        var item = a[i];
        if (item.length == 2) {
            r += &amp;quot;0&amp;quot; + item;
        } else {
            r += item;
        }
    }
    return $.tablesorter.formatFloat(r);
}, type: &amp;quot;numeric&amp;quot;</code></pre>

<p>});</p>

<p>ts.addParser({</p>

<pre><code>id: &amp;quot;url&amp;quot;,
is: function (s) {
    return /^(https?|ftp|file):\/\/$/.test(s);
}, format: function (s) {
    return jQuery.trim(s.replace(new RegExp(/(https?|ftp|file):\/\//), &amp;#39;&amp;#39;));
}, type: &amp;quot;text&amp;quot;</code></pre>

<p>});</p>

<p>ts.addParser({</p>

<pre><code>id: &amp;quot;isoDate&amp;quot;,
is: function (s) {
    return /^\d{4}[\/-]\d{1,2}[\/-]\d{1,2}$/.test(s);
}, format: function (s) {
    return $.tablesorter.formatFloat((s != &amp;quot;&amp;quot;) ? new Date(s.replace(
    new RegExp(/-/g), &amp;quot;/&amp;quot;)).getTime() : &amp;quot;0&amp;quot;);
}, type: &amp;quot;numeric&amp;quot;</code></pre>

<p>});</p>

<p>ts.addParser({</p>

<pre><code>id: &amp;quot;percent&amp;quot;,
is: function (s) {
    return /\%$/.test($.trim(s));
}, format: function (s) {
    return $.tablesorter.formatFloat(s.replace(new RegExp(/%/g), &amp;quot;&amp;quot;));
}, type: &amp;quot;numeric&amp;quot;</code></pre>

<p>});</p>

<p>ts.addParser({</p>

<pre><code>id: &amp;quot;usLongDate&amp;quot;,
is: function (s) {
    return s.match(new RegExp(/^[A-Za-z]{3,10}\.? [0-9]{1,2}, ([0-9]{4}|&amp;#39;?[0-9]{2}) (([0-2]?[0-9]:[0-5][0-9])|([0-1]?[0-9]:[0-5][0-9]\s(AM|PM)))$/));
}, format: function (s) {
    return $.tablesorter.formatFloat(new Date(s).getTime());
}, type: &amp;quot;numeric&amp;quot;</code></pre>

<p>});</p>

<p>ts.addParser({</p>

<pre><code>id: &amp;quot;shortDate&amp;quot;,
is: function (s) {
    return /\d{1,2}[\/\-]\d{1,2}[\/\-]\d{2,4}/.test(s);
}, format: function (s, table) {
    var c = table.config;
    s = s.replace(/\-/g, &amp;quot;/&amp;quot;);
    if (c.dateFormat == &amp;quot;us&amp;quot;) {
        // reformat the string in ISO format
        s = s.replace(/(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{4})/, &amp;quot;$3/$1/$2&amp;quot;);
    } else if (c.dateFormat == &amp;quot;uk&amp;quot;) {
        // reformat the string in ISO format
        s = s.replace(/(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{4})/, &amp;quot;$3/$2/$1&amp;quot;);
    } else if (c.dateFormat == &amp;quot;dd/mm/yy&amp;quot; || c.dateFormat == &amp;quot;dd-mm-yy&amp;quot;) {
        s = s.replace(/(\d{1,2})[\/\-](\d{1,2})[\/\-](\d{2})/, &amp;quot;$1/$2/$3&amp;quot;);
    }
    return $.tablesorter.formatFloat(new Date(s).getTime());
}, type: &amp;quot;numeric&amp;quot;</code></pre>

<p>}); ts.addParser({</p>

<pre><code>id: &amp;quot;time&amp;quot;,
is: function (s) {
    return /^(([0-2]?[0-9]:[0-5][0-9])|([0-1]?[0-9]:[0-5][0-9]\s(am|pm)))$/.test(s);
}, format: function (s) {
    return $.tablesorter.formatFloat(new Date(&amp;quot;2000/01/01 &amp;quot; + s).getTime());
}, type: &amp;quot;numeric&amp;quot;</code></pre>

<p>}); ts.addParser({</p>

<pre><code>id: &amp;quot;metadata&amp;quot;,
is: function (s) {
    return false;
}, format: function (s, table, cell) {
    var c = table.config,
        p = (!c.parserMetadataName) ? &amp;#39;sortValue&amp;#39; : c.parserMetadataName;
    return $(cell).metadata()[p];
}, type: &amp;quot;numeric&amp;quot;</code></pre>

<p>}); // add default widgets ts.addWidget({</p>

<pre><code>id: &amp;quot;zebra&amp;quot;,
format: function (table) {
    if (table.config.debug) {
        var time = new Date();
    }
    var $tr, row = -1,
        odd;
    // loop through the visible rows
    $(&amp;quot;tr:visible&amp;quot;, table.tBodies[0]).each(function (i) {
        $tr = $(this);
        // style children rows the same way the parent
        // row was styled
        if (!$tr.hasClass(table.config.cssChildRow)) row++;
        odd = (row % 2 == 0);
        $tr.removeClass(
        table.config.widgetZebra.css[odd ? 0 : 1]).addClass(
        table.config.widgetZebra.css[odd ? 1 : 0])
    });
    if (table.config.debug) {
        $.tablesorter.benchmark(&amp;quot;Applying Zebra widget&amp;quot;, time);
    }
}</code></pre>

<p>}); &lt;/code&gt;&lt;/pre&gt;</p>

<p>&lt;p&gt;})(jQuery);&lt;/p&gt;</p>

<pre><code>  &lt;/div&gt;

  &lt;!-- Methods --&gt;
            &lt;/div&gt;

  &lt;/div&gt;
&lt;/body&gt;</code></pre>

<p>&lt;/html&gt;</p>

    </div>
  


  


  
  


  


  

  



  

    

    

    


    


    <!-- Methods -->
              </div>

    </div>
  </body>
</html>
