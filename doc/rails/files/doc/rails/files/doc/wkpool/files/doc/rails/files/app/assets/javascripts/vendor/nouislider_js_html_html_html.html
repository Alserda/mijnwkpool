<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
    <title>nouislider_js_html_html.html</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <link rel="stylesheet" href="../../../../../../../../../../../../../../css/reset.css" type="text/css" media="screen" />
<link rel="stylesheet" href="../../../../../../../../../../../../../../css/main.css" type="text/css" media="screen" />
<link rel="stylesheet" href="../../../../../../../../../../../../../../css/github.css" type="text/css" media="screen" />
<script src="../../../../../../../../../../../../../../js/jquery-1.3.2.min.js" type="text/javascript" charset="utf-8"></script>
<script src="../../../../../../../../../../../../../../js/jquery-effect.js" type="text/javascript" charset="utf-8"></script>
<script src="../../../../../../../../../../../../../../js/main.js" type="text/javascript" charset="utf-8"></script>
<script src="../../../../../../../../../../../../../../js/highlight.pack.js" type="text/javascript" charset="utf-8"></script>

</head>

<body>     
    <div class="banner">
        
        <h1>
            nouislider_js_html_html.html
        </h1>
        <ul class="files">
            <li>doc/rails/files/doc/wkpool/files/doc/rails/files/app/assets/javascripts/vendor/nouislider_js_html_html.html</li>
            <li>Last modified: 2014-06-16 16:01:28 +0200</li>
        </ul>
    </div>

    <div id="bodyContent">
        <div id="content">
  
    <div class="description">
      
<p>&lt;!DOCTYPE html PUBLIC “-//W3C//DTD XHTML 1.0 Transitional//EN”</p>

<pre><code>&quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;</code></pre>

<p>&lt;html xmlns=“<a
href="http://www.w3.org/1999/xhtml">www.w3.org/1999/xhtml</a>”
xml:lang=“en” lang=“en”&gt; &lt;head&gt;</p>

<pre><code>&lt;title&gt;nouislider_js_html.html&lt;/title&gt;
&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot; /&gt;
&lt;link rel=&quot;stylesheet&quot; href=&quot;../../../../../../../../../../../css/reset.css&quot; type=&quot;text/css&quot; media=&quot;screen&quot; /&gt;</code></pre>

<p>&lt;link rel=“stylesheet”
href=“../../../../../../../../../../../css/main.css” type=“text/css”
media=“screen” /&gt; &lt;link rel=“stylesheet”
href=“../../../../../../../../../../../css/github.css” type=“text/css”
media=“screen” /&gt; &lt;script
src=“../../../../../../../../../../../js/jquery-1.3.2.min.js”
type=“text/javascript” charset=“utf-8”&gt;&lt;/script&gt; &lt;script
src=“../../../../../../../../../../../js/jquery-effect.js”
type=“text/javascript” charset=“utf-8”&gt;&lt;/script&gt; &lt;script
src=“../../../../../../../../../../../js/main.js” type=“text/javascript”
charset=“utf-8”&gt;&lt;/script&gt; &lt;script
src=“../../../../../../../../../../../js/highlight.pack.js”
type=“text/javascript” charset=“utf-8”&gt;&lt;/script&gt;</p>

<p>&lt;/head&gt;</p>

<p>&lt;body&gt;</p>

<pre><code>&lt;div class=&quot;banner&quot;&gt;

    &lt;h1&gt;
        nouislider_js_html.html
    &lt;/h1&gt;
    &lt;ul class=&quot;files&quot;&gt;
        &lt;li&gt;doc/wkpool/files/doc/rails/files/app/assets/javascripts/vendor/nouislider_js_html.html&lt;/li&gt;
        &lt;li&gt;Last modified: 2014-06-16 15:57:57 +0200&lt;/li&gt;
    &lt;/ul&gt;
&lt;/div&gt;

&lt;div id=&quot;bodyContent&quot;&gt;
    &lt;div id=&quot;content&quot;&gt;

&lt;div class=&quot;description&quot;&gt;</code></pre>

<p>&lt;p&gt;&amp;lt;!DOCTYPE html PUBLIC “-//W3C//DTD XHTML 1.0
Transitional//EN”&lt;/p&gt;</p>

<p>&lt;pre&gt;<code>&amp;quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;</pre</code>&gt;</p>

<p>&lt;p&gt;&amp;lt;html xmlns=“&lt;a href=“<a
href="http://www.w3.org/1999/xhtml">www.w3.org/1999/xhtml</a">www.w3.org/1999/xhtml”>www.w3.org/1999/xhtml</a</a>&gt;”
xml:lang=“en” lang=“en”&amp;gt; &amp;lt;head&amp;gt;&lt;/p&gt;</p>

<p>&lt;pre&gt;<code>&amp;lt;title&amp;gt;nouislider_js.html&amp;lt;/title&amp;gt;
&amp;lt;meta http-equiv=&amp;quot;Content-Type&amp;quot;
content=&amp;quot;text/html; charset=UTF-8&amp;quot; /&amp;gt; &amp;lt;link
rel=&amp;quot;stylesheet&amp;quot;
href=&amp;quot;../../../../../../../../css/reset.css&amp;quot;
type=&amp;quot;text/css&amp;quot; media=&amp;quot;screen&amp;quot;
/&amp;gt;</code>&lt;/pre&gt;</p>

<p>&lt;p&gt;&amp;lt;link rel=“stylesheet”
href=“../../../../../../../../css/main.css” type=“text/css” media=“screen”
/&amp;gt; &amp;lt;link rel=“stylesheet”
href=“../../../../../../../../css/github.css” type=“text/css”
media=“screen” /&amp;gt; &amp;lt;script
src=“../../../../../../../../js/jquery-1.3.2.min.js” type=“text/javascript”
charset=“utf-8”&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;script
src=“../../../../../../../../js/jquery-effect.js” type=“text/javascript”
charset=“utf-8”&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;script
src=“../../../../../../../../js/main.js” type=“text/javascript”
charset=“utf-8”&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;script
src=“../../../../../../../../js/highlight.pack.js” type=“text/javascript”
charset=“utf-8”&amp;gt;&amp;lt;/script&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;/head&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;body&amp;gt;&lt;/p&gt;</p>

<p>&lt;pre&gt;&lt;code&gt;&amp;lt;div class=&amp;quot;banner&amp;quot;&amp;gt;</p>

<pre><code>&amp;lt;h1&amp;gt;
    nouislider_js.html
&amp;lt;/h1&amp;gt;
&amp;lt;ul class=&amp;quot;files&amp;quot;&amp;gt;
    &amp;lt;li&amp;gt;doc/rails/files/app/assets/javascripts/vendor/nouislider_js.html&amp;lt;/li&amp;gt;
    &amp;lt;li&amp;gt;Last modified: 2014-06-16 15:53:37 +0200&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;</code></pre>

<p>&amp;lt;/div&amp;gt;</p>

<p>&amp;lt;div id=&amp;quot;bodyContent&amp;quot;&amp;gt;</p>

<pre><code>&amp;lt;div id=&amp;quot;content&amp;quot;&amp;gt;</code></pre>

<p>&amp;lt;div
class=&amp;quot;description&amp;quot;&amp;gt;&lt;/code&gt;&lt;/pre&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;&amp;amp;lt;!DOCTYPE html PUBLIC “-//W3C//DTD
XHTML 1.0 Transitional//EN”&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;pre&amp;gt;<code>&amp;amp;quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;</pre&gt;</p</code>&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;&amp;amp;lt;html xmlns=“&amp;lt;a href=“&lt;a
href=“<a
href="http://www.w3.org/1999/xhtml">www.w3.org/1999/xhtml</a">www.w3.org/1999/xhtml”>www.w3.org/1999/xhtml</a</a>&gt”>www.w3.org/1999/xhtml“>www.w3.org/1999/xhtml</a">www.w3.org/1999/xhtml”>www.w3.org/1999/xhtml</a</a>&gt</a>;”
xml:lang=“en” lang=“en”&amp;amp;gt;
&amp;amp;lt;head&amp;amp;gt;&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;pre&amp;gt;<code>&amp;amp;lt;title&amp;amp;gt;nouislider.js&amp;amp;lt;/title&amp;amp;gt;
&amp;amp;lt;meta http-equiv=&amp;amp;quot;Content-Type&amp;amp;quot;
content=&amp;amp;quot;text/html; charset=UTF-8&amp;amp;quot; /&amp;amp;gt;
&amp;amp;lt;link rel=&amp;amp;quot;stylesheet&amp;amp;quot;
href=&amp;amp;quot;../../../../../css/reset.css&amp;amp;quot;
type=&amp;amp;quot;text/css&amp;amp;quot;
media=&amp;amp;quot;screen&amp;amp;quot;
/&amp;amp;gt;</code>&amp;lt;/pre&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;&amp;amp;lt;link rel=“stylesheet”
href=“../../../../../css/main.css” type=“text/css” media=“screen”
/&amp;amp;gt; &amp;amp;lt;link rel=“stylesheet”
href=“../../../../../css/github.css” type=“text/css” media=“screen”
/&amp;amp;gt; &amp;amp;lt;script
src=“../../../../../js/jquery-1.3.2.min.js” type=“text/javascript”
charset=“utf-8”&amp;amp;gt;&amp;amp;lt;/script&amp;amp;gt;
&amp;amp;lt;script src=“../../../../../js/jquery-effect.js”
type=“text/javascript”
charset=“utf-8”&amp;amp;gt;&amp;amp;lt;/script&amp;amp;gt;
&amp;amp;lt;script src=“../../../../../js/main.js” type=“text/javascript”
charset=“utf-8”&amp;amp;gt;&amp;amp;lt;/script&amp;amp;gt;
&amp;amp;lt;script src=“../../../../../js/highlight.pack.js”
type=“text/javascript”
charset=“utf-8”&amp;amp;gt;&amp;amp;lt;/script&amp;amp;gt;&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;&amp;amp;lt;/head&amp;amp;gt;&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;&amp;amp;lt;body&amp;amp;gt;&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;pre&amp;gt;&amp;lt;code&amp;gt;&amp;amp;lt;div
class=&amp;amp;quot;banner&amp;amp;quot;&amp;amp;gt;&lt;/p&gt;</p>

<p>&lt;pre&gt;&lt;code&gt;&amp;amp;lt;h1&amp;amp;gt;</p>

<pre><code>nouislider.js</code></pre>

<p>&amp;amp;lt;/h1&amp;amp;gt; &amp;amp;lt;ul
class=&amp;amp;quot;files&amp;amp;quot;&amp;amp;gt;</p>

<pre><code>&amp;amp;lt;li&amp;amp;gt;app/assets/javascripts/vendor/nouislider.js&amp;amp;lt;/li&amp;amp;gt;
&amp;amp;lt;li&amp;amp;gt;Last modified: 2014-06-10 17:47:08 +0200&amp;amp;lt;/li&amp;amp;gt;</code></pre>

<p>&amp;amp;lt;/ul&amp;amp;gt;&lt;/code&gt;&lt;/pre&gt;</p>

<p>&lt;p&gt;&amp;amp;lt;/div&amp;amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;amp;lt;div
id=&amp;amp;quot;bodyContent&amp;amp;quot;&amp;amp;gt;&lt;/p&gt;</p>

<p>&lt;pre&gt;<code>&amp;amp;lt;div
id=&amp;amp;quot;content&amp;amp;quot;&amp;amp;gt;</code>&lt;/pre&gt;</p>

<p>&lt;p&gt;&amp;amp;lt;div
class=&amp;amp;quot;description&amp;amp;quot;&amp;amp;gt;&amp;lt;/code&amp;gt;&amp;lt;/pre&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;&amp;amp;lt;pre&amp;amp;gt;&amp;amp;lt;code&amp;amp;gt;!
$.noUiSlider - WTFPL -
refreshless.com/nouislider/&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;jslint browser:
true&amp;amp;lt;/code&amp;amp;gt;&amp;amp;lt;/pre&amp;amp;gt;&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;&amp;amp;lt;p&amp;amp;gt;  jslint devel: true    
jslint continue: true</p>

<p>jslint plusplus: true&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;pre&amp;gt;&lt;code&gt;/   jslint sub: true      jslint
white: true</p>

<p>&amp;amp;lt;/p&amp;amp;gt;&lt;/code&gt;&amp;lt;/pre&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;&amp;amp;lt;p&amp;amp;gt;// ==ClosureCompiler==
// @externs_url &amp;amp;lt;a href=“&amp;lt;a href=“&lt;a href=“<a
href="http://refreshless.com/externs/jquery-1.8.js">refreshless.com/externs/jquery-1.8.js</a">refreshless.com/externs/jquery-1.8.js”>refreshless.com/externs/jquery-1.8.js</a</a>&gt”>refreshless.com/externs/jquery-1.8.js“>refreshless.com/externs/jquery-1.8.js</a">refreshless.com/externs/jquery-1.8.js”>refreshless.com/externs/jquery-1.8.js</a</a>&gt</a">refreshless.com/externs/jquery-1.8.js”>refreshless.com/externs/jquery-1.8.js</a">refreshless.com/externs/jquery-1.8.js”>refreshless.com/externs/jquery-1.8.js</a</a>&gt”>refreshless.com/externs/jquery-1.8.js“>refreshless.com/externs/jquery-1.8.js</a">refreshless.com/externs/jquery-1.8.js”>refreshless.com/externs/jquery-1.8.js</a</a>&gt</a</a>&gt;;
// @compilation_level ADVANCED_OPTIMIZATIONS // @warning_level VERBOSE
//&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;h2
id=“label-%2FClosureCompiler%3D%3D%3C%2Fp%3E”&amp;gt;/ClosureCompiler==&amp;amp;lt;/p&amp;amp;gt;&amp;lt;/h2&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;&amp;amp;lt;p&amp;amp;gt;(function( $
){&amp;amp;lt;/p&amp;amp;gt;&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;&amp;amp;lt;pre&amp;amp;gt;&amp;amp;lt;code&amp;amp;gt;&amp;amp;amp;#39;use
strict&amp;amp;amp;#39;;&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;var // Cache the document
selector;&amp;amp;lt;/code&amp;amp;gt;&amp;amp;lt;/pre&amp;amp;gt;&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;&amp;amp;lt;p&amp;amp;gt;    @const    doc =
$(document),&amp;amp;lt;/p&amp;amp;gt;&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;&amp;amp;lt;pre&amp;amp;gt;<code>// Namespace for
binding and unbinding slider
events;</code>&amp;amp;lt;/pre&amp;amp;gt;&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;&amp;amp;lt;p&amp;amp;gt;/** @const    namespace
=
&amp;amp;amp;#39;.nui&amp;amp;amp;#39;,&amp;amp;lt;/p&amp;amp;gt;&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;&amp;amp;lt;pre&amp;amp;gt;<code>// Copy of the
current value
function;</code>&amp;amp;lt;/pre&amp;amp;gt;&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;&amp;amp;lt;p&amp;amp;gt;/** @const */ $val =
$.fn.val,&amp;amp;lt;/p&amp;amp;gt;&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;&amp;amp;lt;pre&amp;amp;gt;<code>// Determine the
events to bind. IE11 implements pointerEvents without // a prefix, which
breaks compatibility with the IE10
implementation.</code>&amp;amp;lt;/pre&amp;amp;gt;&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;&amp;amp;lt;p&amp;amp;gt;/** @const */ actions =
window.navigator.pointerEnabled ?
{&amp;amp;lt;/p&amp;amp;gt;&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;&amp;amp;lt;pre&amp;amp;gt;&amp;amp;lt;code&amp;amp;gt;
start:
&amp;amp;amp;#39;pointerdown&amp;amp;amp;#39;,&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;pre&amp;gt;<code>move:
&amp;amp;amp;#39;pointermove&amp;amp;amp;#39;, end:
&amp;amp;amp;#39;pointerup&amp;amp;amp;#39;</code>&amp;lt;/pre&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;} : window.navigator.msPointerEnabled ?
{&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;pre&amp;gt;<code>start:
&amp;amp;amp;#39;MSPointerDown&amp;amp;amp;#39;, move:
&amp;amp;amp;#39;MSPointerMove&amp;amp;amp;#39;, end:
&amp;amp;amp;#39;MSPointerUp&amp;amp;amp;#39;</code>&amp;lt;/pre&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;} : {&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;pre&amp;gt;<code>start: &amp;amp;amp;#39;mousedown
touchstart&amp;amp;amp;#39;, move: &amp;amp;amp;#39;mousemove
touchmove&amp;amp;amp;#39;, end: &amp;amp;amp;#39;mouseup
touchend&amp;amp;amp;#39;</code>&amp;lt;/pre&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;}, // Re-usable list of
classes;&amp;amp;lt;/code&amp;amp;gt;&amp;amp;lt;/pre&amp;amp;gt;&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;&amp;amp;lt;p&amp;amp;gt;/** @const */ Classes =
[ /*  0 */  &amp;amp;amp;#39;noUi-target&amp;amp;amp;#39; /*  1 */
,&amp;amp;amp;#39;noUi-base&amp;amp;amp;#39; /*  2 */
,&amp;amp;amp;#39;noUi-origin&amp;amp;amp;#39; /*  3 */
,&amp;amp;amp;#39;noUi-handle&amp;amp;amp;#39; /*  4 */
,&amp;amp;amp;#39;noUi-horizontal&amp;amp;amp;#39; /*  5 */
,&amp;amp;amp;#39;noUi-vertical&amp;amp;amp;#39; /*  6 */
,&amp;amp;amp;#39;noUi-background&amp;amp;amp;#39; /*  7 */
,&amp;amp;amp;#39;noUi-connect&amp;amp;amp;#39; /*  8 */
,&amp;amp;amp;#39;noUi-ltr&amp;amp;amp;#39; /*  9 */
,&amp;amp;amp;#39;noUi-rtl&amp;amp;amp;#39; /* 10 */
,&amp;amp;amp;#39;noUi-dragable&amp;amp;amp;#39; /* 11 */
,&amp;amp;amp;#39;&amp;amp;amp;#39; /* 12 */
,&amp;amp;amp;#39;noUi-state-drag&amp;amp;amp;#39; /* 13 */
,&amp;amp;amp;#39;&amp;amp;amp;#39; /* 14&lt;/p&gt;</p>

<p>&lt;pre&gt;<code>/ ,&amp;amp;amp;#39;noUi-state-tap&amp;amp;amp;#39; /* 15
*/</code>&lt;/pre&gt;</p>

<p>&lt;p&gt;,&amp;amp;amp;#39;noUi-active&amp;amp;amp;#39; /* 16 */
,&amp;amp;amp;#39;noUi-extended&amp;amp;amp;#39; /* 17 */
,&amp;amp;amp;#39;noUi-stacking&amp;amp;amp;#39;&amp;amp;lt;/p&amp;amp;gt;&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;&amp;amp;lt;pre&amp;amp;gt;<code>],</code>&amp;amp;lt;/pre&amp;amp;gt;&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;&amp;amp;lt;p&amp;amp;gt;/** @const */ Formatting
= [ /*  0 */  &amp;amp;amp;#39;decimals&amp;amp;amp;#39; /*  1 */
,&amp;amp;amp;#39;mark&amp;amp;amp;#39; /*  2 */
,&amp;amp;amp;#39;thousand&amp;amp;amp;#39; /*  3&lt;/p&gt;</p>

<p>&lt;pre&gt;<code>/ ,&amp;amp;amp;#39;prefix&amp;amp;amp;#39; /*  4 */
,&amp;amp;amp;#39;postfix&amp;amp;amp;#39; /*  5 */</code>&lt;/pre&gt;</p>

<p>&lt;p&gt;,&amp;amp;amp;#39;encoder&amp;amp;amp;#39; /*  6 */
,&amp;amp;amp;#39;decoder&amp;amp;amp;#39; /*  7 */
,&amp;amp;amp;#39;negative&amp;amp;amp;#39; /*  8 */
,&amp;amp;amp;#39;negativeBefore&amp;amp;amp;#39;&amp;amp;lt;/p&amp;amp;gt;&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;&amp;amp;lt;pre&amp;amp;gt;<code>],</code>&amp;amp;lt;/pre&amp;amp;gt;&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;&amp;amp;lt;p&amp;amp;gt;/** @const */
FormatDefaults = [ /*  0 */  2 /*  1 */
,&amp;amp;amp;#39;.&amp;amp;amp;#39; /*  2 */
,&amp;amp;amp;#39;&amp;amp;amp;#39; /*  3 */
,&amp;amp;amp;#39;&amp;amp;amp;#39; /*  4 */
,&amp;amp;amp;#39;&amp;amp;amp;#39; /*  5</p>

<pre><code>/ ,function(a){ return a; } /*  6 */ ,function(a){ return a; } /*  7 */</code></pre>

<p>,&amp;amp;amp;#39;-&amp;amp;amp;#39; /*  8 */
,&amp;amp;amp;#39;&amp;amp;amp;#39;&amp;amp;lt;/p&amp;amp;gt;&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;&amp;amp;lt;pre&amp;amp;gt;<code>];</code>&amp;amp;lt;/pre&amp;amp;gt;&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;&amp;amp;lt;p&amp;amp;gt;// Error
handling&amp;amp;lt;/p&amp;amp;gt;&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;&amp;amp;lt;pre&amp;amp;gt;&amp;amp;lt;code&amp;amp;gt;function
throwError( message ){&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;pre&amp;gt;<code>throw new
RangeError(&amp;amp;amp;#39;noUiSlider: &amp;amp;amp;#39; +
message);</code>&amp;lt;/pre&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;}&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;// Throw an error if formatting options are
incompatible. function throwEqualError( F, a, b )
{&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;pre&amp;gt;&amp;lt;code&amp;gt;if ( (&lt;a
href=“a”&gt;F&lt;/a&gt; || &lt;a href=“b”&gt;F&lt;/a&gt;)
&amp;amp;amp;amp;&amp;amp;amp;amp; (&lt;a href=“a”&gt;F&lt;/a&gt; === &lt;a
href=“b”&gt;F&lt;/a&gt;) ) {&lt;/p&gt;</p>

<p>&lt;pre&gt;<code>throwError(&amp;amp;amp;quot;(Link)
&amp;amp;amp;#39;&amp;amp;amp;quot;a&amp;amp;amp;quot;&amp;amp;amp;#39;
can&amp;amp;amp;#39;t match
&amp;amp;amp;#39;&amp;amp;amp;quot;b&amp;amp;amp;quot;&amp;amp;amp;#39;.&amp;amp;amp;#39;&amp;amp;amp;quot;);</code>&lt;/pre&gt;</p>

<p>&lt;p&gt;}&amp;lt;/code&amp;gt;&amp;lt;/pre&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;}&amp;amp;lt;/code&amp;amp;gt;&amp;amp;lt;/pre&amp;amp;gt;&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;&amp;amp;lt;p&amp;amp;gt;// General
helpers&amp;amp;lt;/p&amp;amp;gt;&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;&amp;amp;lt;pre&amp;amp;gt;&amp;amp;lt;code&amp;amp;gt;//
Limits a value to 0 - 100 function limit ( a )
{&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;pre&amp;gt;<code>return Math.max(Math.min(a, 100),
0);</code>&amp;lt;/pre&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;}&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;// Round a value to the closest
&amp;amp;amp;#39;to&amp;amp;amp;#39;. function closest ( value, to )
{&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;pre&amp;gt;<code>return Math.round(value / to) *
to;</code>&amp;lt;/pre&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;}&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;// Determine the size of a sub-range in relation
to a full range. function subRangeRatio ( pa, pb )
{&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;pre&amp;gt;<code>return (100 / (pb -
pa));</code>&amp;lt;/pre&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;}&amp;amp;lt;/code&amp;amp;gt;&amp;amp;lt;/pre&amp;amp;gt;&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;&amp;amp;lt;p&amp;amp;gt;// Type
validation&amp;amp;lt;/p&amp;amp;gt;&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;&amp;amp;lt;pre&amp;amp;gt;&amp;amp;lt;code&amp;amp;gt;function
typeMatch ( a, b ) {&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;pre&amp;gt;<code>return (typeof a) === (typeof
b);</code>&amp;lt;/pre&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;}&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;// Test in an object is an instance of jQuery or
Zepto. function isInstance ( a ) {&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;pre&amp;gt;<code>return a instanceof $ || (
$[&amp;amp;amp;#39;zepto&amp;amp;amp;#39;]
&amp;amp;amp;amp;&amp;amp;amp;amp;
$[&amp;amp;amp;#39;zepto&amp;#39;][&amp;#39;isZ&amp;#39;](a)
);</code>&amp;lt;/pre&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;}&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;// Checks whether a value is numerical. function
isNumeric ( a ) {&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;pre&amp;gt;<code>return typeof a ===
&amp;amp;amp;#39;number&amp;amp;amp;#39; &amp;amp;amp;amp;&amp;amp;amp;amp;
!isNaN( a ) &amp;amp;amp;amp;&amp;amp;amp;amp; isFinite( a
);</code>&amp;lt;/pre&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;}&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;// Wraps a variable as an array, if it
isn&amp;amp;amp;#39;t one yet. function asArray ( a )
{&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;pre&amp;gt;<code>return $.isArray(a) ? a :
[a];</code>&amp;lt;/pre&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;}&amp;amp;lt;/code&amp;amp;gt;&amp;amp;lt;/pre&amp;amp;gt;&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;&amp;amp;lt;p&amp;amp;gt;// Class
handling&amp;amp;lt;/p&amp;amp;gt;&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;&amp;amp;lt;pre&amp;amp;gt;&amp;amp;lt;code&amp;amp;gt;//
Sets a class and removes it after [duration] ms. function addClassFor (
element, className, duration ) {&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;pre&amp;gt;&amp;lt;code&amp;gt;element.addClass(className);
setTimeout(function(){&lt;/p&gt;</p>

<p>&lt;pre&gt;<code>element.removeClass(className);</code>&lt;/pre&gt;</p>

<p>&lt;p&gt;}, duration);&amp;lt;/code&amp;gt;&amp;lt;/pre&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;}&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;// Tests if element has a class, adds it if not.
Returns original state. function getsClass ( element, className )
{&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;pre&amp;gt;&amp;lt;code&amp;gt;var has =
element.hasClass(className);&lt;/p&gt;</p>

<p>&lt;p&gt;if ( !has ) {&lt;/p&gt;</p>

<p>&lt;pre&gt;<code>element.addClass( className );</code>&lt;/pre&gt;</p>

<p>&lt;p&gt;}&lt;/p&gt;</p>

<p>&lt;p&gt;return has;&amp;lt;/code&amp;gt;&amp;lt;/pre&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;}
&amp;amp;lt;/code&amp;amp;gt;&amp;amp;lt;/pre&amp;amp;gt;&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;&amp;amp;lt;p&amp;amp;gt;// Value
calculation&amp;amp;lt;/p&amp;amp;gt;&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;&amp;amp;lt;pre&amp;amp;gt;&amp;amp;lt;code&amp;amp;gt;//
(percentage) How many percent is this value of this range? function
fromPercentage ( range, value ) {&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;pre&amp;gt;<code>return (value * 100) / ( range[1] -
range[0] );</code>&amp;lt;/pre&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;}&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;// (percentage) Where is this value on this
range? function toPercentage ( range, value ) {&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;pre&amp;gt;&amp;lt;code&amp;gt;return fromPercentage(
range, &lt;a href=“0”&gt;range&lt;/a&gt; &amp;amp;amp;lt; 0 ?&lt;/p&gt;</p>

<p>&lt;pre&gt;&lt;code&gt;value + <a href="0">Math.abs(range</a>) :</p>

<pre><code>value - range[0] );&amp;lt;/code&amp;gt;&amp;lt;/pre&amp;gt;&lt;/code&gt;&lt;/pre&gt;</code></pre>

<p>&lt;p&gt;&amp;lt;p&amp;gt;}&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;// (value) How much is this percentage on this
range? function isPercentage ( range, value ) {&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;pre&amp;gt;<code>return ((value * ( range[1] - range[0] ))
/ 100) + range[0];</code>&amp;lt;/pre&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;}&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;// (percentage) function toStepping ( options,
value ) {&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;pre&amp;gt;&amp;lt;code&amp;gt;if ( value
&amp;amp;amp;gt;= &lt;a href=“0”&gt;options.xVal.slice(-1)&lt;/a&gt;
){&lt;/p&gt;</p>

<p>&lt;pre&gt;<code>return 100;</code>&lt;/pre&gt;</p>

<p>&lt;p&gt;}&lt;/p&gt;</p>

<p>&lt;p&gt;var j = 1, va, vb, pa, pb; while ( value &amp;amp;amp;gt;= &lt;a
href=“j”&gt;options.xVal&lt;/a&gt; ){&lt;/p&gt;</p>

<p>&lt;pre&gt;<code>j++;</code>&lt;/pre&gt;</p>

<p>&lt;p&gt;}&lt;/p&gt;</p>

<p>&lt;p&gt;va = &lt;a href=“j-1”&gt;options.xVal&lt;/a&gt;; vb = &lt;a
href=“j”&gt;options.xVal&lt;/a&gt;; pa</p>

<h1 id="label-%3Ca+href%3D%22j-1%22%3Eoptions.xPct%3C%2Fa%3E%3B+pb+%3D+%3Ca+href%3D%22j%22%3Eoptions.xPct%3C%2Fa%3E%3B%3C%2Fp%3E">&lt;a href=“j-1”&gt;options.xPct&lt;/a&gt;; pb = &lt;a href=“j”&gt;options.xPct&lt;/a&gt;;&lt;/p&gt;</h1>

<p>&lt;p&gt;return pa + (toPercentage([va, vb], value) / subRangeRatio (pa,
pb));&amp;lt;/code&amp;gt;&amp;lt;/pre&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;}&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;// (value) function fromStepping ( options, value
) {&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;pre&amp;gt;&amp;lt;code&amp;gt;// There is no range group
that fits 100 if ( value &amp;amp;amp;gt;= 100 ){&lt;/p&gt;</p>

<p>&lt;pre&gt;<code>return options.xVal.slice(-1)[0];</code>&lt;/pre&gt;</p>

<p>&lt;p&gt;}&lt;/p&gt;</p>

<p>&lt;p&gt;var j = 1, va, vb, pa, pb; while ( value &amp;amp;amp;gt;= &lt;a
href=“j”&gt;options.xPct&lt;/a&gt; ){&lt;/p&gt;</p>

<p>&lt;pre&gt;<code>j++;</code>&lt;/pre&gt;</p>

<p>&lt;p&gt;}&lt;/p&gt;</p>

<p>&lt;p&gt;va = &lt;a href=“j-1”&gt;options.xVal&lt;/a&gt;; vb = &lt;a
href=“j”&gt;options.xVal&lt;/a&gt;; pa</p>

<h1 id="label-%3Ca+href%3D%22j-1%22%3Eoptions.xPct%3C%2Fa%3E%3B+pb+%3D+%3Ca+href%3D%22j%22%3Eoptions.xPct%3C%2Fa%3E%3B%3C%2Fp%3E">&lt;a href=“j-1”&gt;options.xPct&lt;/a&gt;; pb = &lt;a href=“j”&gt;options.xPct&lt;/a&gt;;&lt;/p&gt;</h1>

<p>&lt;p&gt;return isPercentage([va, vb], (value - pa) * subRangeRatio (pa,
pb));&amp;lt;/code&amp;gt;&amp;lt;/pre&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;}&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;// (percentage) Get the step that applies at a
certain value. function getStep ( options, value
){&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;pre&amp;gt;&amp;lt;code&amp;gt;var j = 1, a, b; while (
value &amp;amp;amp;gt;= &lt;a href=“j”&gt;options.xPct&lt;/a&gt;
){&lt;/p&gt;</p>

<p>&lt;pre&gt;<code>j++;</code>&lt;/pre&gt;</p>

<p>&lt;p&gt;}&lt;/p&gt;</p>

<p>&lt;p&gt;if ( options.snap ) {&lt;/p&gt;</p>

<p>&lt;pre&gt;&lt;code&gt;a = <a href="j-1">options.xPct</a>; b = <a
href="j">options.xPct</a>;</p>

<p>if ((value - a) &amp;amp;amp;gt; ((b-a)/2)){</p>

<pre><code>return b;</code></pre>

<p>}</p>

<p>return a;&lt;/code&gt;&lt;/pre&gt;</p>

<p>&lt;p&gt;}&lt;/p&gt;</p>

<p>&lt;p&gt;if ( !&lt;a href=“j-1”&gt;options.xSteps&lt;/a&gt; ){&lt;/p&gt;</p>

<p>&lt;pre&gt;<code>return value;</code>&lt;/pre&gt;</p>

<p>&lt;p&gt;}&lt;/p&gt;</p>

<p>&lt;p&gt;return &lt;a href=“j-1”&gt;options.xPct&lt;/a&gt; +
closest(&lt;/p&gt;</p>

<p>&lt;pre&gt;<code>value - options.xPct[j-1],
options.xSteps[j-1]</code>&lt;/pre&gt;</p>

<p>&lt;p&gt;);&amp;lt;/code&amp;gt;&amp;lt;/pre&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;}&amp;amp;lt;/code&amp;amp;gt;&amp;amp;lt;/pre&amp;amp;gt;&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;&amp;amp;lt;p&amp;amp;gt;// Event
handling&amp;amp;lt;/p&amp;amp;gt;&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;&amp;amp;lt;pre&amp;amp;gt;&amp;amp;lt;code&amp;amp;gt;//
Provide a clean event with standardized offset values. function fixEvent (
e ) {&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;pre&amp;gt;&amp;lt;code&amp;gt;// Prevent scrolling and
panning on touch events, while // attempting to slide. The tap event also
depends on this. e.preventDefault();&lt;/p&gt;</p>

<p>&lt;p&gt;// Filter the event to register the type, which can be // touch,
mouse or pointer. Offset changes need to be // made on an event specific
basis. var  touch = e.type.indexOf(&amp;amp;amp;#39;touch&amp;amp;amp;#39;)
=== 0&lt;/p&gt;</p>

<p>&lt;pre&gt;<code>,mouse =
e.type.indexOf(&amp;amp;amp;#39;mouse&amp;amp;amp;#39;) === 0 ,pointer =
e.type.indexOf(&amp;amp;amp;#39;pointer&amp;amp;amp;#39;) === 0 ,x,y, event
= e;</code>&lt;/pre&gt;</p>

<p>&lt;p&gt;// IE10 implemented pointer events with a prefix; if (
e.type.indexOf(&amp;amp;amp;#39;MSPointer&amp;amp;amp;#39;) === 0 )
{&lt;/p&gt;</p>

<p>&lt;pre&gt;<code>pointer = true;</code>&lt;/pre&gt;</p>

<p>&lt;p&gt;}&lt;/p&gt;</p>

<p>&lt;p&gt;// Get the originalEvent, if the event has been wrapped // by
jQuery. Zepto doesn&amp;amp;amp;#39;t wrap the event. if ( e.originalEvent
) {&lt;/p&gt;</p>

<p>&lt;pre&gt;<code>e = e.originalEvent;</code>&lt;/pre&gt;</p>

<p>&lt;p&gt;}&lt;/p&gt;</p>

<p>&lt;p&gt;if ( touch ) {&lt;/p&gt;</p>

<p>&lt;pre&gt;<code>// noUiSlider supports one movement at a time, // so we
can select the first &amp;amp;amp;#39;changedTouch&amp;amp;amp;#39;. x =
e.changedTouches[0].pageX; y =
e.changedTouches[0].pageY;</code>&lt;/pre&gt;</p>

<p>&lt;p&gt;}&lt;/p&gt;</p>

<p>&lt;p&gt;if ( mouse || pointer ) {&lt;/p&gt;</p>

<p>&lt;pre&gt;&lt;code&gt;// Polyfill the pageXOffset and pageYOffset //
variables for IE7 and IE8; if( !pointer &amp;amp;amp;amp;&amp;amp;amp;amp;
window.pageXOffset === undefined ){</p>

<pre><code>window.pageXOffset = document.documentElement.scrollLeft;
window.pageYOffset = document.documentElement.scrollTop;</code></pre>

<p>}</p>

<p>x = e.clientX + window.pageXOffset; y = e.clientY +
window.pageYOffset;&lt;/code&gt;&lt;/pre&gt;</p>

<p>&lt;p&gt;}&lt;/p&gt;</p>

<p>&lt;p&gt;event.points = [x, y]; event.cursor = mouse;&lt;/p&gt;</p>

<p>&lt;p&gt;return event;&amp;lt;/code&amp;gt;&amp;lt;/pre&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;}&amp;amp;lt;/code&amp;amp;gt;&amp;amp;lt;/pre&amp;amp;gt;&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;&amp;amp;lt;p&amp;amp;gt;// Organize formatting
in an object.&amp;amp;lt;/p&amp;amp;gt;&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;&amp;amp;lt;pre&amp;amp;gt;&amp;amp;lt;code&amp;amp;gt;/**
@constructor */ function Format( options ){&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;pre&amp;gt;&amp;lt;code&amp;gt;// If no settings where
provided, the defaults will be loaded. if ( options === undefined
){&lt;/p&gt;</p>

<p>&lt;pre&gt;<code>options = {};</code>&lt;/pre&gt;</p>

<p>&lt;p&gt;}&lt;/p&gt;</p>

<p>&lt;p&gt;if ( typeof options !== &amp;amp;amp;#39;object&amp;amp;amp;#39;
){&lt;/p&gt;</p>

<p>&lt;pre&gt;<code>throwError(&amp;amp;amp;quot;(Format)
&amp;amp;amp;#39;format&amp;amp;amp;#39; option must be an
object.&amp;amp;amp;quot;);</code>&lt;/pre&gt;</p>

<p>&lt;p&gt;}&lt;/p&gt;</p>

<p>&lt;p&gt;var settings = {};&lt;/p&gt;</p>

<p>&lt;p&gt;// Copy all values into a new object.
$(Formatting).each(function(i, val){&lt;/p&gt;</p>

<p>&lt;pre&gt;&lt;code&gt;if ( <a href="val">options</a> === undefined ){</p>

<pre><code>settings[val] = FormatDefaults[i];</code></pre>

<p>// When we aren&amp;amp;amp;#39;t loading defaults, validate the entry. }
else if ( <a href="val">typeMatch(options</a>,  <a
href="i">FormatDefaults</a>) ) {</p>

<pre><code>// Support for up to 7 decimals.
// More can&amp;amp;amp;#39;t be guaranteed due to floating point issues.
if ( val === &amp;amp;amp;#39;decimals&amp;amp;amp;#39; ){
        if ( options[val] &amp;amp;amp;lt; 0 || options[val] &amp;amp;amp;gt; 7 ){
                throwError(&amp;amp;amp;quot;(Format) &amp;amp;amp;#39;format.decimals&amp;amp;amp;#39; option must be between 0 and 7.&amp;amp;amp;quot;);
        }
}

settings[val] = options[val];</code></pre>

<p>// If the value isn&amp;amp;amp;#39;t valid, emit an error. } else {</p>

<pre><code>throwError(&amp;amp;amp;quot;(Format) &amp;amp;amp;#39;format.&amp;amp;amp;quot;+val+&amp;amp;amp;quot;&amp;amp;amp;#39; must be a &amp;amp;amp;quot; + typeof FormatDefaults[i] + &amp;amp;amp;quot;.&amp;amp;amp;quot;);</code></pre>

<p>}&lt;/code&gt;&lt;/pre&gt;</p>

<p>&lt;p&gt;});&lt;/p&gt;</p>

<p>&lt;p&gt;// Some values can&amp;amp;amp;#39;t be extracted from a // string
if certain combinations are present. throwEqualError(settings,
&amp;amp;amp;#39;mark&amp;amp;amp;#39;,
&amp;amp;amp;#39;thousand&amp;amp;amp;#39;); throwEqualError(settings,
&amp;amp;amp;#39;prefix&amp;amp;amp;#39;,
&amp;amp;amp;#39;negative&amp;amp;amp;#39;); throwEqualError(settings,
&amp;amp;amp;#39;prefix&amp;amp;amp;#39;,
&amp;amp;amp;#39;negativeBefore&amp;amp;amp;#39;);&lt;/p&gt;</p>

<p>&lt;p&gt;this.settings =
settings;&amp;lt;/code&amp;gt;&amp;lt;/pre&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;}&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;// Shorthand for internal value get
Format.prototype.v = function ( a ) {&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;pre&amp;gt;<code>return
this.settings[a];</code>&amp;lt;/pre&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;};&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;Format.prototype.to = function ( number )
{&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;pre&amp;gt;&amp;lt;code&amp;gt;function reverse ( a )
{&lt;/p&gt;</p>

<p>&lt;pre&gt;<code>return
a.split(&amp;amp;amp;#39;&amp;amp;amp;#39;).reverse().join(&amp;amp;amp;#39;&amp;amp;amp;#39;);</code>&lt;/pre&gt;</p>

<p>&lt;p&gt;}&lt;/p&gt;</p>

<p>&lt;p&gt;number = this.v(&amp;amp;amp;#39;encoder&amp;amp;amp;#39;)( number
);&lt;/p&gt;</p>

<p>&lt;p&gt;var negative = &amp;amp;amp;#39;&amp;amp;amp;#39;, preNegative =
&amp;amp;amp;#39;&amp;amp;amp;#39;, base =
&amp;amp;amp;#39;&amp;amp;amp;#39;, mark =
&amp;amp;amp;#39;&amp;amp;amp;#39;;&lt;/p&gt;</p>

<p>&lt;p&gt;if ( number &amp;amp;amp;lt; 0 ) {&lt;/p&gt;</p>

<p>&lt;pre&gt;<code>negative =
this.v(&amp;amp;amp;#39;negative&amp;amp;amp;#39;); preNegative =
this.v(&amp;amp;amp;#39;negativeBefore&amp;amp;amp;#39;);</code>&lt;/pre&gt;</p>

<p>&lt;p&gt;}&lt;/p&gt;</p>

<p>&lt;p&gt;// Round to proper decimal count number =
Math.abs(number).toFixed(
this.v(&amp;amp;amp;#39;decimals&amp;amp;amp;#39;) ).toString(); number =
number.split(&amp;amp;amp;#39;.&amp;amp;amp;#39;);&lt;/p&gt;</p>

<p>&lt;p&gt;// Rounding away decimals might cause a value of -0 // when using
very small ranges. Remove those cases. if ( parseFloat(number) === 0 )
{&lt;/p&gt;</p>

<p>&lt;<a href="0">pre>number</a><code> =
&amp;amp;amp;#39;0&amp;amp;amp;#39;;</code>&lt;/pre&gt;</p>

<p>&lt;p&gt;}&lt;/p&gt;</p>

<p>&lt;p&gt;// Group numbers in sets of three. if (
this.v(&amp;amp;amp;#39;thousand&amp;amp;amp;#39;) ) {&lt;/p&gt;</p>

<p>&lt;pre&gt;<code>base = reverse(number[0]).match(/.{1,3}/g); base =
reverse(base.join(reverse(
this.v(&amp;amp;amp;#39;thousand&amp;amp;amp;#39;) )));</code>&lt;/pre&gt;</p>

<p>&lt;p&gt;} else {&lt;/p&gt;</p>

<p>&lt;pre&gt;<code>base = number[0];</code>&lt;/pre&gt;</p>

<p>&lt;p&gt;}&lt;/p&gt;</p>

<p>&lt;p&gt;// Ignore the decimal separator if decimals are set to 0. if (
this.v(&amp;amp;amp;#39;mark&amp;amp;amp;#39;)
&amp;amp;amp;amp;&amp;amp;amp;amp; number.length &amp;amp;amp;gt; 1 )
{&lt;/p&gt;</p>

<p>&lt;pre&gt;<code>mark = this.v(&amp;amp;amp;#39;mark&amp;amp;amp;#39;) +
number[1];</code>&lt;/pre&gt;</p>

<p>&lt;p&gt;}&lt;/p&gt;</p>

<p>&lt;p&gt;// Return the finalized formatted number. return preNegative
+&lt;/p&gt;</p>

<p>&lt;pre&gt;<code>this.v(&amp;amp;amp;#39;prefix&amp;amp;amp;#39;) +
negative + base + mark +
this.v(&amp;amp;amp;#39;postfix&amp;amp;amp;#39;);&amp;lt;/code&amp;gt;&amp;lt;/pre&amp;gt;</code>&lt;/pre&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;};&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;Format.prototype.from = function ( input )
{&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;pre&amp;gt;&amp;lt;code&amp;gt;function esc(s){&lt;/p&gt;</p>

<p>&lt;pre&gt;<code>return s.replace(/[\-\/\\^$*+?.()|\[\]{}]/g,
&amp;amp;amp;#39;\$&amp;amp;amp;amp;&amp;amp;amp;#39;);</code>&lt;/pre&gt;</p>

<p>&lt;p&gt;}&lt;/p&gt;</p>

<p>&lt;p&gt;var isNeg; // The set request might want to ignore this handle. //
Test for &amp;amp;amp;#39;undefined&amp;amp;amp;#39; too, as a two-handle
slider // can still be set with an integer. if( input === null || input ===
undefined ) {&lt;/p&gt;</p>

<p>&lt;pre&gt;<code>return false;</code>&lt;/pre&gt;</p>

<p>&lt;p&gt;}&lt;/p&gt;</p>

<p>&lt;p&gt;// Remove formatting and set period for float parsing. input =
input.toString();&lt;/p&gt;</p>

<p>&lt;p&gt;// Replace the preNegative indicator. isNeg = input.replace(new
RegExp(&amp;amp;amp;#39;^&amp;amp;amp;#39; + esc(
this.v(&amp;amp;amp;#39;negativeBefore&amp;amp;amp;#39;) )),
&amp;amp;amp;#39;&amp;amp;amp;#39;);&lt;/p&gt;</p>

<p>&lt;p&gt;// Check if the value changed by removing the negativeBefore
symbol. if( input !== isNeg ) {&lt;/p&gt;</p>

<p>&lt;pre&gt;<code>input = isNeg; isNeg =
&amp;amp;amp;#39;-&amp;amp;amp;#39;;</code>&lt;/pre&gt;</p>

<p>&lt;p&gt;} else {&lt;/p&gt;</p>

<p>&lt;pre&gt;<code>isNeg =
&amp;amp;amp;#39;&amp;amp;amp;#39;;</code>&lt;/pre&gt;</p>

<p>&lt;p&gt;}&lt;/p&gt;</p>

<p>&lt;p&gt;// If prefix is set and the number is actually prefixed. input =
input.replace(new RegExp(&amp;amp;amp;#39;^&amp;amp;amp;#39;+esc(
this.v(&amp;amp;amp;#39;prefix&amp;amp;amp;#39;) )),
&amp;amp;amp;#39;&amp;amp;amp;#39;);&lt;/p&gt;</p>

<p>&lt;p&gt;// Only replace if a negative sign is set. if ( &lt;a
href=“&amp;amp;#39;negative&amp;amp;#39;”&gt;this.v&lt;/a&gt; ) {&lt;/p&gt;</p>

<p>&lt;pre&gt;&lt;code&gt;// Reset isNeg to prevent double
&amp;amp;amp;#39;-&amp;amp;amp;#39; insertion. isNeg =
&amp;amp;amp;#39;&amp;amp;amp;#39;;</p>

<p>// Reset the negative sign to &amp;amp;amp;#39;-&amp;amp;amp;#39; input =
input.replace(new RegExp(&amp;amp;amp;#39;^&amp;amp;amp;#39;+esc(
this.v(&amp;amp;amp;#39;negative&amp;amp;amp;#39;) )),
&amp;amp;amp;#39;-&amp;amp;amp;#39;);&lt;/code&gt;&lt;/pre&gt;</p>

<p>&lt;p&gt;}&lt;/p&gt;</p>

<p>&lt;p&gt;// Clean the input string input = input // If postfix is set and
the number is postfixed.&lt;/p&gt;</p>

<p>&lt;pre&gt;<code>.replace( new RegExp(esc(
this.v(&amp;amp;amp;#39;postfix&amp;amp;amp;#39;) ) +
&amp;amp;amp;#39;$&amp;amp;amp;#39;),
&amp;amp;amp;#39;&amp;amp;amp;#39;)</code>&lt;/pre&gt;</p>

<p>&lt;p&gt;// Remove the separator every three digits.&lt;/p&gt;</p>

<p>&lt;pre&gt;<code>.replace( new RegExp(esc(
this.v(&amp;amp;amp;#39;thousand&amp;amp;amp;#39;) ),
&amp;amp;amp;#39;g&amp;amp;amp;#39;),
&amp;amp;amp;#39;&amp;amp;amp;#39;)</code>&lt;/pre&gt;</p>

<p>&lt;p&gt;// Set the decimal separator back to period.&lt;/p&gt;</p>

<p>&lt;pre&gt;<code>.replace( this.v(&amp;amp;amp;#39;mark&amp;amp;amp;#39;),
&amp;amp;amp;#39;.&amp;amp;amp;#39;);</code>&lt;/pre&gt;</p>

<p>&lt;p&gt;// Run the user defined decoder. Returns input by default. input =
this.v(&amp;amp;amp;#39;decoder&amp;amp;amp;#39;)( parseFloat( isNeg +
input ) );&lt;/p&gt;</p>

<p>&lt;p&gt;// Ignore invalid input if (isNaN( input )) {&lt;/p&gt;</p>

<p>&lt;pre&gt;<code>return false;</code>&lt;/pre&gt;</p>

<p>&lt;p&gt;}&lt;/p&gt;</p>

<p>&lt;p&gt;return input;&amp;lt;/code&amp;gt;&amp;lt;/pre&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;};&amp;amp;lt;/code&amp;amp;gt;&amp;amp;lt;/pre&amp;amp;gt;&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;&amp;amp;lt;p&amp;amp;gt;// Serialization
target&amp;amp;lt;/p&amp;amp;gt;&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;&amp;amp;lt;p&amp;amp;gt;/** @constructor
*/&amp;amp;lt;/p&amp;amp;gt;&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;&amp;amp;lt;pre&amp;amp;gt;&amp;amp;lt;code&amp;amp;gt;function
Link( entry, update ){&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;pre&amp;gt;&amp;lt;code&amp;gt;// Make sure Link
isn&amp;amp;amp;#39;t called as a function, in which case // the
&amp;amp;amp;#39;this&amp;amp;amp;#39; scope would be the window. if (
!(this instanceof Link) ) {&lt;/p&gt;</p>

<p>&lt;pre&gt;&lt;code&gt;throw new Error( &amp;amp;amp;quot;Link:
&amp;amp;amp;quot; +</p>

<pre><code>&amp;amp;amp;quot;Don&amp;amp;amp;#39;t use Link as a function. &amp;amp;amp;quot; +
&amp;amp;amp;quot;Use the &amp;amp;amp;#39;new&amp;amp;amp;#39; keyword.&amp;amp;amp;quot;);&lt;/code&gt;&lt;/pre&gt;</code></pre>

<p>&lt;p&gt;}&lt;/p&gt;</p>

<p>&lt;p&gt;if ( !entry ) {&lt;/p&gt;</p>

<p>&lt;pre&gt;<code>throw new RangeError(&amp;amp;amp;quot;Link: missing
parameters.&amp;amp;amp;quot;);</code>&lt;/pre&gt;</p>

<p>&lt;p&gt;}&lt;/p&gt;</p>

<p>&lt;p&gt;// Write all formatting to this object. // No validation needed,
as we&amp;amp;amp;#39;ll merge these with the parent // format options
first. this.formatting = &lt;a
href=“&amp;amp;#39;format&amp;amp;#39;”&gt;entry&lt;/a&gt; || {};&lt;/p&gt;</p>

<p>&lt;p&gt;// Store the update option. this.update = !update;&lt;/p&gt;</p>

<p>&lt;p&gt;// In IE &amp;amp;amp;lt; 9, .bind() isn&amp;amp;amp;#39;t
available, need this link in
.change().&amp;lt;/code&amp;gt;&amp;lt;/pre&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;var that = this,&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;pre&amp;gt;&amp;lt;code&amp;gt;// Get values from the
input. target = &lt;a
href=“&amp;amp;#39;target&amp;amp;#39;”&gt;entry&lt;/a&gt; || function(){},
method = &lt;a
href=“&amp;amp;#39;method&amp;amp;#39;”&gt;entry&lt;/a&gt;,&lt;/p&gt;</p>

<p>&lt;p&gt;// Find the type of this link. isTooltip = ( typeof target ===
&amp;amp;amp;#39;string&amp;amp;amp;#39; &amp;amp;amp;amp;&amp;amp;amp;amp;
target.indexOf(&amp;amp;amp;#39;-tooltip-&amp;amp;amp;#39;) === 0 ),
isHidden = ( typeof target === &amp;amp;amp;#39;string&amp;amp;amp;#39;
&amp;amp;amp;amp;&amp;amp;amp;amp;
target.indexOf(&amp;amp;amp;#39;-&amp;amp;amp;#39;) !== 0 ), isMethod = (
typeof target === &amp;amp;amp;#39;function&amp;amp;amp;#39; ), is$ = (
isInstance(target) ), isInput = ( is$ &amp;amp;amp;amp;&amp;amp;amp;amp;
target.is(&amp;amp;amp;#39;input, select, textarea&amp;amp;amp;#39;) ),
methodIsFunction = ( is$ &amp;amp;amp;amp;&amp;amp;amp;amp; typeof method
=== &amp;amp;amp;#39;function&amp;amp;amp;#39; ), methodIsName = ( is$
&amp;amp;amp;amp;&amp;amp;amp;amp; typeof method ===
&amp;amp;amp;#39;string&amp;amp;amp;#39; &amp;amp;amp;amp;&amp;amp;amp;amp;
&lt;a href=“method”&gt;target&lt;/a&gt; );&lt;/p&gt;</p>

<p>&lt;p&gt;// If target is a string, a new hidden input will be created. if (
isTooltip ) {&lt;/p&gt;</p>

<p>&lt;pre&gt;&lt;code&gt;// By default, use the
&amp;amp;amp;#39;html&amp;amp;amp;#39; method. this.method = method ||
&amp;amp;amp;#39;html&amp;amp;amp;#39;;</p>

<p>// Use jQuery to create the element this.el = $(
target.replace(&amp;amp;amp;#39;-tooltip-&amp;amp;amp;#39;,
&amp;amp;amp;#39;&amp;amp;amp;#39;) ||
&amp;amp;amp;#39;&amp;amp;amp;lt;div/&amp;amp;amp;gt;&amp;amp;amp;#39;
)[0];</p>

<p>return;&lt;/code&gt;&lt;/pre&gt;</p>

<p>&lt;p&gt;}&lt;/p&gt;</p>

<p>&lt;p&gt;// If the string doesn&amp;amp;amp;#39;t begin with
&amp;amp;amp;#39;-&amp;amp;amp;#39;, which is reserved, add a new hidden
input. if ( isHidden ) {&lt;/p&gt;</p>

<p>&lt;pre&gt;&lt;code&gt;this.method = &amp;amp;amp;#39;val&amp;amp;amp;#39;;</p>

<p>this.el = document.createElement(&amp;amp;amp;#39;input&amp;amp;amp;#39;);
this.el.name = target; this.el.type =
&amp;amp;amp;#39;hidden&amp;amp;amp;#39;;</p>

<p>return;&lt;/code&gt;&lt;/pre&gt;</p>

<p>&lt;p&gt;}&lt;/p&gt;</p>

<p>&lt;p&gt;// The target can also be a function, which will be called. if (
isMethod ) {&lt;/p&gt;</p>

<p>&lt;pre&gt;<code>this.target = false; this.method = target;
return;</code>&lt;/pre&gt;</p>

<p>&lt;p&gt;}&lt;/p&gt;</p>

<p>&lt;p&gt;// If the target is and $ element. if ( is$ ) {&lt;/p&gt;</p>

<p>&lt;pre&gt;&lt;code&gt;// The method must exist on the element. if ( method
&amp;amp;amp;amp;&amp;amp;amp;amp; ( methodIsFunction || methodIsName ) ) {</p>

<pre><code>this.target = target;
this.method = method;
return;</code></pre>

<p>}</p>

<p>// If a jQuery/Zepto input element is provided, but no method is set, //
the element can assume it needs to respond to
&amp;amp;amp;#39;change&amp;amp;amp;#39;… if ( !method
&amp;amp;amp;amp;&amp;amp;amp;amp; isInput ) {</p>

<pre><code>// Default to .val if this is an input element.
this.method = &amp;amp;amp;#39;val&amp;amp;amp;#39;;
this.target = target;

// Set the slider to a new value on change.
this.target.on(&amp;amp;amp;#39;change&amp;amp;amp;#39;, function( e ){

        // Returns null array.
        function at(a,b,c){
                return [c?a:b, c?b:a];
        }

        var output = at(null, $(e.target).val(), that.N);

        that.obj.val(output, { &amp;amp;amp;#39;link&amp;amp;amp;#39;: that });
});

return;</code></pre>

<p>}</p>

<p>// … or not. if ( !method &amp;amp;amp;amp;&amp;amp;amp;amp; !isInput ) {</p>

<pre><code>// Default arbitrarily to &amp;amp;amp;#39;html&amp;amp;amp;#39;.
this.method = &amp;amp;amp;#39;html&amp;amp;amp;#39;;
this.target = target;

return;</code></pre>

<p>}&lt;/code&gt;&lt;/pre&gt;</p>

<p>&lt;p&gt;}&lt;/p&gt;</p>

<p>&lt;p&gt;throw new RangeError(&amp;amp;amp;quot;Link: Invalid
Link.&amp;amp;amp;quot;);&amp;lt;/code&amp;gt;&amp;lt;/pre&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;}&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;// Provides external items with the slider value.
Link.prototype.write = function ( options, value, handle, slider, update )
{&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;pre&amp;gt;&amp;lt;code&amp;gt;// Don&amp;amp;amp;#39;t
synchronize this Link. if ( this.update &amp;amp;amp;amp;&amp;amp;amp;amp;
update === false ) {&lt;/p&gt;</p>

<p>&lt;pre&gt;<code>return;</code>&lt;/pre&gt;</p>

<p>&lt;p&gt;}&lt;/p&gt;</p>

<p>&lt;p&gt;// Convert the value to the slider stepping/range. value =
fromStepping( options, value );&lt;/p&gt;</p>

<p>&lt;p&gt;// Format values for display. value = this.format( value
);&lt;/p&gt;</p>

<p>&lt;p&gt;// Store the numerical value. this.saved = value;&lt;/p&gt;</p>

<p>&lt;p&gt;// Branch between serialization to a function or an object. if (
typeof this.method === &amp;amp;amp;#39;function&amp;amp;amp;#39; )
{&lt;/p&gt;</p>

<p>&lt;pre&gt;<code>// When target is undefined, the target was a function. //
In that case, provided the slider as the calling scope. // Use [0] to get
the DOM element, not the $ instance. this.method.call( this.target[0] ||
slider[0], value, handle, slider );</code>&lt;/pre&gt;</p>

<p>&lt;p&gt;} else {&lt;/p&gt;</p>

<p>&lt;pre&gt;<code>this.target[ this.method ]( value, handle, slider
);</code>&lt;/pre&gt;</p>

<p>&lt;p&gt;}&amp;lt;/code&amp;gt;&amp;lt;/pre&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;};&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;// Parses slider value to user defined display.
Link.prototype.format = function ( a ) {&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;pre&amp;gt;<code>return
this.formatting.to(a);</code>&amp;lt;/pre&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;};&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;// Converts a formatted value back to a real
number. Link.prototype.valueOf&lt;/p&gt;</p>

<p>&lt;h1 id=“label-function+%28+a+%29+%7B%3C%2Fp%3E”&gt;function ( a )
{&amp;lt;/p&amp;gt;&lt;/h1&gt;</p>

<p>&lt;p&gt;&amp;lt;pre&amp;gt;<code>return
this.formatting.from(a);</code>&amp;lt;/pre&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;};&amp;amp;lt;/code&amp;amp;gt;&amp;amp;lt;/pre&amp;amp;gt;&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;&amp;amp;lt;p&amp;amp;gt;// Input
validation&amp;amp;lt;/p&amp;amp;gt;&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;&amp;amp;lt;pre&amp;amp;gt;&amp;amp;lt;code&amp;amp;gt;function
testStep ( parsed, entry ) {&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;pre&amp;gt;&amp;lt;code&amp;gt;if ( !isNumeric( entry ) )
{&lt;/p&gt;</p>

<p>&lt;pre&gt;<code>throwError(&amp;amp;amp;quot;&amp;amp;amp;#39;step&amp;amp;amp;#39;
is not numeric.&amp;amp;amp;quot;);</code>&lt;/pre&gt;</p>

<p>&lt;p&gt;}&lt;/p&gt;</p>

<p>&lt;p&gt;// The step option can still be used to set stepping // for linear
sliders. Overwritten if set in &amp;amp;amp;#39;range&amp;amp;amp;#39;.
&lt;a href=“0”&gt;parsed.xSteps&lt;/a&gt; =
entry;&amp;lt;/code&amp;gt;&amp;lt;/pre&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;}&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;function testRange ( parsed, entry )
{&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;pre&amp;gt;&amp;lt;code&amp;gt;// Filter incorrect input.
if ( typeof entry !== &amp;amp;amp;#39;object&amp;amp;amp;#39; ||
$.isArray(entry) ) {&lt;/p&gt;</p>

<p>&lt;pre&gt;<code>throwError(&amp;amp;amp;quot;&amp;amp;amp;#39;range&amp;amp;amp;#39;
is not an object.&amp;amp;amp;quot;);</code>&lt;/pre&gt;</p>

<p>&lt;p&gt;}&lt;/p&gt;</p>

<p>&lt;p&gt;// Loop all entries. $.each( entry, function ( index, value )
{&lt;/p&gt;</p>

<p>&lt;pre&gt;&lt;code&gt;var percentage;</p>

<p>// Wrap numerical input in an array. if ( typeof value ===
&amp;amp;amp;quot;number&amp;amp;amp;quot; ) {</p>

<pre><code>value = [value];</code></pre>

<p>}</p>

<p>// Reject any invalid input. if ( !$.isArray( value ) ){</p>

<pre><code>throwError(&amp;amp;amp;quot;&amp;amp;amp;#39;range&amp;amp;amp;#39; contains invalid value.&amp;amp;amp;quot;);</code></pre>

<p>}</p>

<p>// Covert min/max syntax to 0 and 100. if ( index ===
&amp;amp;amp;#39;min&amp;amp;amp;#39; ) {</p>

<pre><code>percentage = 0;</code></pre>

<p>} else if ( index === &amp;amp;amp;#39;max&amp;amp;amp;#39; ) {</p>

<pre><code>percentage = 100;</code></pre>

<p>} else {</p>

<pre><code>percentage = parseFloat( index );</code></pre>

<p>}</p>

<p>// Check for correct input. if ( !isNumeric( percentage ) || !isNumeric( <a
href="0">value</a> ) ) {</p>

<pre><code>throwError(&amp;amp;amp;quot;&amp;amp;amp;#39;range&amp;amp;amp;#39; value isn&amp;amp;amp;#39;t numeric.&amp;amp;amp;quot;);</code></pre>

<p>}</p>

<p>// Store values. parsed.xPct.push( percentage ); parsed.xVal.push( <a
href="0">value</a> );</p>

<p>// NaN will evaluate to false too, but to keep // logging clear, set step
explicitly. Make sure // not to override the
&amp;amp;amp;#39;step&amp;amp;amp;#39; setting with false. if ( !percentage
) {</p>

<pre><code>if ( !isNaN( value[1] ) ) {
        parsed.xSteps[0] = value[1];
}</code></pre>

<p>} else {</p>

<pre><code>parsed.xSteps.push( isNaN(value[1]) ? false : value[1] );</code></pre>

<p>}&lt;/code&gt;&lt;/pre&gt;</p>

<p>&lt;p&gt;});&lt;/p&gt;</p>

<p>&lt;p&gt;$.each(parsed.xSteps, function(i,n){&lt;/p&gt;</p>

<p>&lt;pre&gt;&lt;code&gt;// Ignore &amp;amp;amp;#39;false&amp;amp;amp;#39;
stepping. if ( !n ) {</p>

<pre><code>return true;</code></pre>

<p>}</p>

<p>// Check if step fits. Not required, but this might serve some goal. //
!((<a href="i+1">parsed.xVal</a> - <a href="i">parsed.xVal</a>) % n);</p>

<p>// Factor to range ratio <a href="i">parsed.xSteps</a> = fromPercentage([</p>

<pre><code> parsed.xVal[i]
,parsed.xVal[i+1]</code></pre>

<p>], n) / subRangeRatio (</p>

<pre><code>parsed.xPct[i],
parsed.xPct[i+1] );&lt;/code&gt;&lt;/pre&gt;</code></pre>

<p>&lt;p&gt;});&amp;lt;/code&amp;gt;&amp;lt;/pre&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;}&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;function testStart ( parsed, entry )
{&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;pre&amp;gt;&amp;lt;code&amp;gt;if ( typeof entry ===
&amp;amp;amp;quot;number&amp;amp;amp;quot; ) {&lt;/p&gt;</p>

<p>&lt;pre&gt;<code>entry = [entry];</code>&lt;/pre&gt;</p>

<p>&lt;p&gt;}&lt;/p&gt;</p>

<p>&lt;p&gt;// Validate input. Values aren&amp;amp;amp;#39;t tested, the
internal Link will do // that and provide a valid location. if (
!$.isArray( entry ) || !entry.length || entry.length &amp;amp;amp;gt; 2 )
{&lt;/p&gt;</p>

<p>&lt;pre&gt;<code>throwError(&amp;amp;amp;quot;&amp;amp;amp;#39;start&amp;amp;amp;#39;
option is incorrect.&amp;amp;amp;quot;);</code>&lt;/pre&gt;</p>

<p>&lt;p&gt;}&lt;/p&gt;</p>

<p>&lt;p&gt;// Store the number of handles. parsed.handles =
entry.length;&lt;/p&gt;</p>

<p>&lt;p&gt;// When the slider is initialized, the .val method will // be
called with the start options. parsed.start =
entry;&amp;lt;/code&amp;gt;&amp;lt;/pre&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;}&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;function testSnap ( parsed, entry )
{&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;pre&amp;gt;&amp;lt;code&amp;gt;// Enforce 100% stepping
within subranges. parsed.snap = entry;&lt;/p&gt;</p>

<p>&lt;p&gt;if ( typeof entry !== &amp;amp;amp;#39;boolean&amp;amp;amp;#39;
){&lt;/p&gt;</p>

<p>&lt;pre&gt;<code>throwError(&amp;amp;amp;quot;&amp;amp;amp;#39;snap&amp;amp;amp;#39;
option must be a boolean.&amp;amp;amp;quot;);</code>&lt;/pre&gt;</p>

<p>&lt;p&gt;}&amp;lt;/code&amp;gt;&amp;lt;/pre&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;}&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;function testConnect ( parsed, entry )
{&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;pre&amp;gt;&amp;lt;code&amp;gt;if ( entry ===
&amp;amp;amp;#39;lower&amp;amp;amp;#39; &amp;amp;amp;amp;&amp;amp;amp;amp;
parsed.handles === 1 ) {&lt;/p&gt;</p>

<p>&lt;pre&gt;<code>parsed.connect = 1;</code>&lt;/pre&gt;</p>

<p>&lt;p&gt;} else if ( entry === &amp;amp;amp;#39;upper&amp;amp;amp;#39;
&amp;amp;amp;amp;&amp;amp;amp;amp; parsed.handles === 1 ) {&lt;/p&gt;</p>

<p>&lt;pre&gt;<code>parsed.connect = 2;</code>&lt;/pre&gt;</p>

<p>&lt;p&gt;} else if ( entry === true &amp;amp;amp;amp;&amp;amp;amp;amp;
parsed.handles === 2 ) {&lt;/p&gt;</p>

<p>&lt;pre&gt;<code>parsed.connect = 3;</code>&lt;/pre&gt;</p>

<p>&lt;p&gt;} else if ( entry === false ) {&lt;/p&gt;</p>

<p>&lt;pre&gt;<code>parsed.connect = 0;</code>&lt;/pre&gt;</p>

<p>&lt;p&gt;} else {&lt;/p&gt;</p>

<p>&lt;pre&gt;<code>throwError(&amp;amp;amp;quot;&amp;amp;amp;#39;connect&amp;amp;amp;#39;
option was doesn&amp;amp;amp;#39;t match handle
count.&amp;amp;amp;quot;);</code>&lt;/pre&gt;</p>

<p>&lt;p&gt;}&amp;lt;/code&amp;gt;&amp;lt;/pre&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;}&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;function testOrientation ( parsed, entry )
{&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;pre&amp;gt;&amp;lt;code&amp;gt;// Set orientation to an a
numerical value for easy // array selection. switch ( entry ){&lt;/p&gt;</p>

<p>&lt;pre&gt;&lt;code&gt;case &amp;amp;amp;#39;horizontal&amp;amp;amp;#39;:</p>

<pre><code>parsed.ort = 0;
break;</code></pre>

<p>case &amp;amp;amp;#39;vertical&amp;amp;amp;#39;:</p>

<pre><code>parsed.ort = 1;
break;</code></pre>

<p>default:</p>

<pre><code>throwError(&amp;amp;amp;quot;&amp;amp;amp;#39;orientation&amp;amp;amp;#39; option is invalid.&amp;amp;amp;quot;);&lt;/code&gt;&lt;/pre&gt;</code></pre>

<p>&lt;p&gt;}&amp;lt;/code&amp;gt;&amp;lt;/pre&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;}&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;function testMargin ( parsed, entry )
{&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;pre&amp;gt;&amp;lt;code&amp;gt;if ( parsed.xPct.length
&amp;amp;amp;gt; 2 ) {&lt;/p&gt;</p>

<p>&lt;pre&gt;<code>throwError(&amp;amp;amp;quot;&amp;amp;amp;#39;margin&amp;amp;amp;#39;
option is only supported on linear
sliders.&amp;amp;amp;quot;);</code>&lt;/pre&gt;</p>

<p>&lt;p&gt;}&lt;/p&gt;</p>

<p>&lt;p&gt;// Parse value to range and store. As xVal is checked // to be no
bigger than 2, use it as range. parsed.margin = fromPercentage(parsed.xVal,
entry);&lt;/p&gt;</p>

<p>&lt;p&gt;if ( !isNumeric(entry) ){&lt;/p&gt;</p>

<p>&lt;pre&gt;<code>throwError(&amp;amp;amp;quot;&amp;amp;amp;#39;margin&amp;amp;amp;#39;
option must be numeric.&amp;amp;amp;quot;);</code>&lt;/pre&gt;</p>

<p>&lt;p&gt;}&amp;lt;/code&amp;gt;&amp;lt;/pre&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;}&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;function testDirection ( parsed, entry )
{&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;pre&amp;gt;&amp;lt;code&amp;gt;// Set direction as a
numerical value for easy parsing. // Invert connection for RTL sliders, so
that the proper // handles get the connect/background classes. switch (
entry ) {&lt;/p&gt;</p>

<p>&lt;pre&gt;&lt;code&gt;case &amp;amp;amp;#39;ltr&amp;amp;amp;#39;:</p>

<pre><code>parsed.dir = 0;
break;</code></pre>

<p>case &amp;amp;amp;#39;rtl&amp;amp;amp;#39;:</p>

<pre><code>parsed.dir = 1;
parsed.connect = [0,2,1,3][parsed.connect];
break;</code></pre>

<p>default:</p>

<pre><code>throwError(&amp;amp;amp;quot;&amp;amp;amp;#39;direction&amp;amp;amp;#39; option was not recognized.&amp;amp;amp;quot;);&lt;/code&gt;&lt;/pre&gt;</code></pre>

<p>&lt;p&gt;}&amp;lt;/code&amp;gt;&amp;lt;/pre&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;}&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;function testBehaviour ( parsed, entry )
{&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;pre&amp;gt;&amp;lt;code&amp;gt;// Make sure the input is a
string. if ( typeof entry !== &amp;amp;amp;#39;string&amp;amp;amp;#39; )
{&lt;/p&gt;</p>

<p>&lt;pre&gt;<code>throwError(&amp;amp;amp;quot;&amp;amp;amp;#39;behaviour&amp;amp;amp;#39;
must be a string containing options.&amp;amp;amp;quot;);</code>&lt;/pre&gt;</p>

<p>&lt;p&gt;}&lt;/p&gt;</p>

<p>&lt;p&gt;// Check if the string contains any keywords. // None are
required. var tap</p>

<h1 id="label-entry.indexOf%28%26amp%3Bamp%3B%2339%3Btap%26amp%3Bamp%3B%2339%3B%29+%26amp%3Bamp%3Bgt%3B%3D+0%2C%3C%2Fp%3E">entry.indexOf(&amp;amp;amp;#39;tap&amp;amp;amp;#39;) &amp;amp;amp;gt;= 0,&lt;/p&gt;</h1>

<p>&lt;pre&gt;<code>extend =
entry.indexOf(&amp;amp;amp;#39;extend&amp;amp;amp;#39;) &amp;amp;amp;gt;=
0, drag = entry.indexOf(&amp;amp;amp;#39;drag&amp;amp;amp;#39;)
&amp;amp;amp;gt;= 0, fixed =
entry.indexOf(&amp;amp;amp;#39;fixed&amp;amp;amp;#39;) &amp;amp;amp;gt;= 0,
snap = entry.indexOf(&amp;amp;amp;#39;snap&amp;amp;amp;#39;)
&amp;amp;amp;gt;= 0;</code>&lt;/pre&gt;</p>

<p>&lt;p&gt;parsed.events = {&lt;/p&gt;</p>

<p>&lt;pre&gt;<code>tap: tap || snap, extend: extend, drag: drag, fixed:
fixed, snap: snap</code>&lt;/pre&gt;</p>

<p>&lt;p&gt;};&amp;lt;/code&amp;gt;&amp;lt;/pre&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;}&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;function testSerialization ( parsed, entry,
sliders ) {&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;pre&amp;gt;&amp;lt;code&amp;gt;parsed.ser = [ &lt;a
href=“&amp;amp;#39;lower&amp;amp;#39;”&gt;entry&lt;/a&gt;, &lt;a
href=“&amp;amp;#39;upper&amp;amp;#39;”&gt;entry&lt;/a&gt; ];
parsed.formatting = new Format( &lt;a
href=“&amp;amp;#39;format&amp;amp;#39;”&gt;entry&lt;/a&gt; );&lt;/p&gt;</p>

<p>&lt;p&gt;$.each( parsed.ser, function( i, a ){&lt;/p&gt;</p>

<p>&lt;pre&gt;&lt;code&gt;// Check if the provided option is an array. if (
!$.isArray(a) ) {</p>

<pre><code>throwError(&amp;amp;amp;quot;&amp;amp;amp;#39;serialization.&amp;amp;amp;quot;+(!i?&amp;amp;amp;#39;lower&amp;amp;amp;#39;:&amp;amp;amp;#39;upper&amp;amp;amp;#39;)+&amp;amp;amp;quot;&amp;amp;amp;#39; must be an array.&amp;amp;amp;quot;);</code></pre>

<p>}</p>

<p>$.each(a, function(){</p>

<pre><code>// Check if entry is a Link.
if ( !(this instanceof Link) ) {
        throwError(&amp;amp;amp;quot;&amp;amp;amp;#39;serialization.&amp;amp;amp;quot;+(!i?&amp;amp;amp;#39;lower&amp;amp;amp;#39;:&amp;amp;amp;#39;upper&amp;amp;amp;#39;)+&amp;amp;amp;quot;&amp;amp;amp;#39; can only contain Link instances.&amp;amp;amp;quot;);
}

// Assign other properties.
this.N = i;
this.obj = sliders;
this.scope = this.scope || sliders;

// Run internal validator.
this.formatting = new Format($.extend({}
        ,entry[&amp;amp;amp;#39;format&amp;amp;amp;#39;]
        ,this.formatting
));</code></pre>

<p>});&lt;/code&gt;&lt;/pre&gt;</p>

<p>&lt;p&gt;});&lt;/p&gt;</p>

<p>&lt;p&gt;// If the slider has two handles and is RTL, // reverse the
serialization input. For one handle, // lower is still lower. if (
parsed.dir &amp;amp;amp;amp;&amp;amp;amp;amp; parsed.handles
&amp;amp;amp;gt; 1 ) {&lt;/p&gt;</p>

<p>&lt;pre&gt;<code>parsed.ser.reverse();</code>&lt;/pre&gt;</p>

<p>&lt;p&gt;}&amp;lt;/code&amp;gt;&amp;lt;/pre&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;}&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;// Test all developer settings and parse to
assumption-safe values. function test ( options, sliders
){&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;/*      Every input option is tested and parsed.
This&amp;amp;amp;#39;ll prevent&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;pre&amp;gt;&amp;lt;code&amp;gt;endless validation in
internal methods. These tests are structured with an item for every option
available. An option can be marked as required by setting the
&amp;amp;amp;#39;r&amp;amp;amp;#39; flag. The testing function is provided
with three arguments:&lt;/p&gt;</p>

<p>&lt;pre&gt;&lt;code&gt;- The provided value for the option;</p>
<ul><li>
<p>A reference to the options object;</p>
</li><li>
<p>The name for the option;&lt;/code&gt;&lt;/pre&gt;</p>
</li></ul>

<p>&lt;p&gt;The testing function returns false when an error is detected, or
true when everything is OK. It can also modify the option object, to make
sure all values can be correctly looped elsewhere. */&lt;/p&gt;</p>

<p>&lt;p&gt;var parsed = {&lt;/p&gt;</p>

<p>&lt;pre&gt;<code> xPct: [] ,xVal: [] ,xSteps: [ false ] ,margin:
0</code>&lt;/pre&gt;</p>

<p>&lt;p&gt;}, tests;&lt;/p&gt;</p>

<p>&lt;p&gt;tests = {&lt;/p&gt;</p>

<p>&lt;pre&gt;<code>&amp;amp;amp;#39;step&amp;amp;amp;#39;: { r: false, t:
testStep }, &amp;amp;amp;#39;range&amp;amp;amp;#39;: { r: true, t:
testRange }, &amp;amp;amp;#39;start&amp;amp;amp;#39;: { r: true, t:
testStart }, &amp;amp;amp;#39;snap&amp;amp;amp;#39;: { r: false, t:
testSnap }, &amp;amp;amp;#39;connect&amp;amp;amp;#39;: { r: true, t:
testConnect }, &amp;amp;amp;#39;orientation&amp;amp;amp;#39;: { r: false,
t: testOrientation }, &amp;amp;amp;#39;margin&amp;amp;amp;#39;: { r: false,
t: testMargin }, &amp;amp;amp;#39;direction&amp;amp;amp;#39;: { r: true, t:
testDirection }, &amp;amp;amp;#39;behaviour&amp;amp;amp;#39;: { r: true, t:
testBehaviour }, &amp;amp;amp;#39;serialization&amp;amp;amp;#39;: { r:
true, t: testSerialization }</code>&lt;/pre&gt;</p>

<p>&lt;p&gt;};&lt;/p&gt;</p>

<p>&lt;p&gt;// Set defaults where applicable. options = $.extend({&lt;/p&gt;</p>

<p>&lt;pre&gt;<code> &amp;amp;amp;#39;connect&amp;amp;amp;#39;: false
,&amp;amp;amp;#39;direction&amp;amp;amp;#39;:
&amp;amp;amp;#39;ltr&amp;amp;amp;#39;
,&amp;amp;amp;#39;behaviour&amp;amp;amp;#39;:
&amp;amp;amp;#39;tap&amp;amp;amp;#39;
,&amp;amp;amp;#39;orientation&amp;amp;amp;#39;:
&amp;amp;amp;#39;horizontal&amp;amp;amp;#39;</code>&lt;/pre&gt;</p>

<p>&lt;p&gt;}, options);&lt;/p&gt;</p>

<p>&lt;p&gt;// Make sure the test for serialization runs. &lt;a
href=“&amp;amp;#39;serialization&amp;amp;#39;”&gt;options&lt;/a&gt; =
$.extend({&lt;/p&gt;</p>

<p>&lt;pre&gt;<code> &amp;amp;amp;#39;lower&amp;amp;amp;#39;: []
,&amp;amp;amp;#39;upper&amp;amp;amp;#39;: []
,&amp;amp;amp;#39;format&amp;amp;amp;#39;: {}</code>&lt;/pre&gt;</p>

<p>&lt;p&gt;}, &lt;a
href=“&amp;amp;#39;serialization&amp;amp;#39;”&gt;options&lt;/a&gt;);&lt;/p&gt;</p>

<p>&lt;p&gt;// Run all options through a testing mechanism to ensure correct
// input. It should be noted that options might get modified to // be
handled properly. E.g. wrapping integers in arrays. $.each( tests,
function( name, test ){&lt;/p&gt;</p>

<p>&lt;pre&gt;&lt;code&gt;if ( <a href="name">options</a> === undefined ) {</p>

<pre><code>if ( test.r ) {
        throwError(&amp;amp;amp;quot;&amp;amp;amp;#39;&amp;amp;amp;quot; + name + &amp;amp;amp;quot;&amp;amp;amp;#39; is required.&amp;amp;amp;quot;);
} else {
        return true;
}</code></pre>

<p>}</p>

<p>test.t( parsed, <a href="name">options</a>, sliders
);&lt;/code&gt;&lt;/pre&gt;</p>

<p>&lt;p&gt;});&lt;/p&gt;</p>

<p>&lt;p&gt;// Pre-define the styles. parsed.style = parsed.ort ?
&amp;amp;amp;#39;top&amp;amp;amp;#39; :
&amp;amp;amp;#39;left&amp;amp;amp;#39;;&lt;/p&gt;</p>

<p>&lt;p&gt;return parsed;&amp;lt;/code&amp;gt;&amp;lt;/pre&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;}&amp;amp;lt;/code&amp;amp;gt;&amp;amp;lt;/pre&amp;amp;gt;&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;&amp;amp;lt;p&amp;amp;gt;// DOM
additions&amp;amp;lt;/p&amp;amp;gt;&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;&amp;amp;lt;pre&amp;amp;gt;&amp;amp;lt;code&amp;amp;gt;//
Append a handle to the base. function addHandle ( options, index )
{&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;pre&amp;gt;&amp;lt;code&amp;gt;var handle =
$(&amp;amp;amp;#39;&amp;amp;amp;lt;div&amp;amp;amp;gt;&amp;amp;amp;lt;div/&amp;amp;amp;gt;&amp;amp;amp;lt;/div&amp;amp;amp;gt;&amp;amp;amp;#39;).addClass(
&lt;a href=“2”&gt;Classes&lt;/a&gt; ),&lt;/p&gt;</p>

<p>&lt;pre&gt;<code>additions = [ &amp;amp;amp;#39;-lower&amp;amp;amp;#39;,
&amp;amp;amp;#39;-upper&amp;amp;amp;#39; ];</code>&lt;/pre&gt;</p>

<p>&lt;p&gt;if ( options.dir ) {&lt;/p&gt;</p>

<p>&lt;pre&gt;<code>additions.reverse();</code>&lt;/pre&gt;</p>

<p>&lt;p&gt;}&lt;/p&gt;</p>

<p>&lt;p&gt;handle.children().addClass(&lt;/p&gt;</p>

<p>&lt;<a href="3">pre>Classes</a><code> + &amp;amp;amp;quot;
&amp;amp;amp;quot; + Classes[3]+additions[index]</code>&lt;/pre&gt;</p>

<p>&lt;p&gt;);&lt;/p&gt;</p>

<p>&lt;p&gt;return handle;&amp;lt;/code&amp;gt;&amp;lt;/pre&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;}&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;// Create a copy of an element-creating Link.
function addElement ( handle, link ) {&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;pre&amp;gt;&amp;lt;code&amp;gt;// If the Link requires
creation of a new element, // create this element and return a new Link
instance. if ( link.el ) {&lt;/p&gt;</p>

<p>&lt;pre&gt;&lt;code&gt;link = new Link({</p>

<pre><code>&amp;amp;amp;#39;target&amp;amp;amp;#39;: $(link.el).clone().appendTo( handle ),
&amp;amp;amp;#39;method&amp;amp;amp;#39;: link.method,
&amp;amp;amp;#39;format&amp;amp;amp;#39;: link.formatting</code></pre>

<p>}, true);&lt;/code&gt;&lt;/pre&gt;</p>

<p>&lt;p&gt;}&lt;/p&gt;</p>

<p>&lt;p&gt;// Otherwise, return the reference. return
link;&amp;lt;/code&amp;gt;&amp;lt;/pre&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;}&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;// Loop all links for a handle. function
addElements ( elements, handle, formatting ) {&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;pre&amp;gt;&amp;lt;code&amp;gt;var index, list =
[];&lt;/p&gt;</p>

<p>&lt;p&gt;// Use the Link interface to provide unified // formatting for the
.val() method. list.push(&lt;/p&gt;</p>

<p>&lt;pre&gt;&lt;code&gt;new Link({</p>

<pre><code>&amp;amp;amp;#39;format&amp;amp;amp;#39;: formatting</code></pre>

<p>}, true)&lt;/code&gt;&lt;/pre&gt;</p>

<p>&lt;p&gt;);&lt;/p&gt;</p>

<p>&lt;p&gt;// Loop all links in either
&amp;amp;amp;#39;lower&amp;amp;amp;#39; or
&amp;amp;amp;#39;upper&amp;amp;amp;#39;. for ( index = 0; index
&amp;amp;amp;lt; elements.length; index++ ) {&lt;/p&gt;</p>

<p>&lt;pre&gt;<code>list.push(addElement(handle,
elements[index]));</code>&lt;/pre&gt;</p>

<p>&lt;p&gt;}&lt;/p&gt;</p>

<p>&lt;p&gt;return list;&amp;lt;/code&amp;gt;&amp;lt;/pre&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;}&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;// Go over all Links and assign them to a handle.
function addLinks ( options, handles ) {&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;pre&amp;gt;&amp;lt;code&amp;gt;var index, links =
[];&lt;/p&gt;</p>

<p>&lt;p&gt;// Copy the links into a new array, instead of modifying // the
&amp;amp;amp;#39;options.ser&amp;amp;amp;#39; list. This allows replacement
of the invalid // &amp;amp;amp;#39;.el&amp;amp;amp;#39; Links, while the
others are still passed by reference. for ( index = 0; index
&amp;amp;amp;lt; options.handles; index++ ) {&lt;/p&gt;</p>

<p>&lt;pre&gt;&lt;code&gt;// Append a new array. <a href="index">links</a> =
addElements(</p>

<pre><code>options.ser[index],
handles[index].children(),
options.formatting</code></pre>

<p>);&lt;/code&gt;&lt;/pre&gt;</p>

<p>&lt;p&gt;}&lt;/p&gt;</p>

<p>&lt;p&gt;return links;&amp;lt;/code&amp;gt;&amp;lt;/pre&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;}&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;// Add the proper connection classes. function
addConnection ( connect, target, handles ) {&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;pre&amp;gt;&amp;lt;code&amp;gt;// Apply the required
connection classes to the elements // that need them. Some classes are made
up for several // segments listed in the class list, to allow easy //
renaming and provide a minor compression benefit. switch ( connect )
{&lt;/p&gt;</p>

<p>&lt;pre&gt;&lt;code&gt;case 1: target.addClass( <a href="7">Classes</a> );</p>

<pre><code>handles[0].addClass( Classes[6] );
break;</code></pre>

<p>case 3: <a href="1">handles</a>.addClass( <a href="6">Classes</a> );</p>

<pre><code>/* falls through */</code></pre>

<p>case 2: <a href="0">handles</a>.addClass( <a href="7">Classes</a> );</p>

<pre><code>/* falls through */</code></pre>

<p>case 0: <a href="6">target.addClass(Classes</a>);</p>

<pre><code>break;&lt;/code&gt;&lt;/pre&gt;</code></pre>

<p>&lt;p&gt;} &amp;lt;/code&amp;gt;&amp;lt;/pre&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;}&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;// Add handles and loop Link elements. function
addHandles ( options, base ) {&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;pre&amp;gt;&amp;lt;code&amp;gt;var index, handles =
[];&lt;/p&gt;</p>

<p>&lt;p&gt;// Append handles. for ( index = 0; index &amp;amp;amp;lt;
options.handles; index++ ) {&lt;/p&gt;</p>

<p>&lt;pre&gt;<code>// Keep a list of all added handles. handles.push(
addHandle( options, index ).appendTo(base) );</code>&lt;/pre&gt;</p>

<p>&lt;p&gt;}&lt;/p&gt;</p>

<p>&lt;p&gt;return handles;&amp;lt;/code&amp;gt;&amp;lt;/pre&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;}&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;// Initialize a single slider. function addSlider
( options, target ) {&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;pre&amp;gt;&amp;lt;code&amp;gt;// Apply classes and data
to the target. target.addClass([&lt;/p&gt;</p>

<p>&lt;<a href="0">pre>Classes</a><code>, Classes[8 + options.dir], Classes[4
+ options.ort]</code>&lt;/pre&gt;</p>

<p>&lt;p&gt;].join(&amp;amp;amp;#39; &amp;amp;amp;#39;));&lt;/p&gt;</p>

<p>&lt;p&gt;return
$(&amp;amp;amp;#39;&amp;amp;amp;lt;div/&amp;amp;amp;gt;&amp;amp;amp;#39;).appendTo(target).addClass(
&lt;a href=“1”&gt;Classes&lt;/a&gt;
);&amp;lt;/code&amp;gt;&amp;lt;/pre&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;}
&amp;amp;lt;/code&amp;amp;gt;&amp;amp;lt;/pre&amp;amp;gt;&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;&amp;amp;lt;p&amp;amp;gt;// Slider
scope&amp;amp;lt;/p&amp;amp;gt;&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;&amp;amp;lt;p&amp;amp;gt;function closure (
target, options, originalOptions
){&amp;amp;lt;/p&amp;amp;gt;&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;&amp;amp;lt;p&amp;amp;gt;// Internal
variables&amp;amp;lt;/p&amp;amp;gt;&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;&amp;amp;lt;pre&amp;amp;gt;&amp;amp;lt;code&amp;amp;gt;//
All variables local to &amp;amp;amp;#39;closure&amp;amp;amp;#39; are marked
$. var $Target = $(target),&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;pre&amp;gt;<code>$Locations = [-1, -1], $Base,
$Serialization, $Handles;</code>&amp;lt;/pre&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;// Shorthand for base dimensions. function
baseSize ( ) {&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;pre&amp;gt;<code>return
$Base[[&amp;amp;amp;#39;width&amp;amp;amp;#39;,
&amp;amp;amp;#39;height&amp;#39;][options.ort]]();</code>&amp;lt;/pre&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;}&amp;amp;lt;/code&amp;amp;gt;&amp;amp;lt;/pre&amp;amp;gt;&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;&amp;amp;lt;p&amp;amp;gt;// External event
handling&amp;amp;lt;/p&amp;amp;gt;&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;&amp;amp;lt;pre&amp;amp;gt;&amp;amp;lt;code&amp;amp;gt;function
fireEvents ( events ) {&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;pre&amp;gt;&amp;lt;code&amp;gt;// Use the external api to
get the values. // Wrap the values in an array, as .trigger takes // only
one additional argument. var index, values = [ $Target.val() ];&lt;/p&gt;</p>

<p>&lt;p&gt;for ( index = 0; index &amp;amp;amp;lt; events.length; index++
){&lt;/p&gt;</p>

<p>&lt;<a href="index">pre>$Target.trigger(events</a><code>,
values);</code>&lt;/pre&gt;</p>

<p>&lt;p&gt;}&amp;lt;/code&amp;gt;&amp;lt;/pre&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;}&amp;amp;lt;/code&amp;amp;gt;&amp;amp;lt;/pre&amp;amp;gt;&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;&amp;amp;lt;p&amp;amp;gt;// Handle
placement&amp;amp;lt;/p&amp;amp;gt;&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;&amp;amp;lt;pre&amp;amp;gt;&amp;amp;lt;code&amp;amp;gt;//
Test suggested values and apply margin, step. function setHandle ( handle,
to, delimit ) {&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;pre&amp;gt;&amp;lt;code&amp;gt;var n = &lt;a
href=“0”&gt;handle&lt;/a&gt; !== $&lt;a <a
href="0">href=“0”>Handles</a></a> ? 1 : 0,&lt;/p&gt;</p>

<p>&lt;pre&gt;<code>lower = $Locations[0] + options.margin, upper =
$Locations[1] - options.margin;</code>&lt;/pre&gt;</p>

<p>&lt;p&gt;// Don&amp;amp;amp;#39;t delimit range dragging. if ( delimit
&amp;amp;amp;amp;&amp;amp;amp;amp; $Handles.length &amp;amp;amp;gt; 1 )
{&lt;/p&gt;</p>

<p>&lt;pre&gt;<code>to = n ? Math.max( to, lower ) : Math.min( to, upper
);</code>&lt;/pre&gt;</p>

<p>&lt;p&gt;}&lt;/p&gt;</p>

<p>&lt;p&gt;// Handle the step option. if ( to &amp;amp;amp;lt; 100
){&lt;/p&gt;</p>

<p>&lt;pre&gt;<code>to = getStep(options, to);</code>&lt;/pre&gt;</p>

<p>&lt;p&gt;}&lt;/p&gt;</p>

<p>&lt;p&gt;// Limit to 0/100 for .val input, trim anything beyond 7 digits,
as // JavaScript has some issues in its floating point implementation. to =
limit(parseFloat(to.toFixed(7)));&lt;/p&gt;</p>

<p>&lt;p&gt;// Return falsy if handle can&amp;amp;amp;#39;t move. False for 0
or 100 limit, // &amp;amp;amp;#39;0&amp;amp;amp;#39; for limiting by
another handle. if ( to === $&lt;a href=“n”&gt;Locations&lt;/a&gt; )
{&lt;/p&gt;</p>

<p>&lt;pre&gt;&lt;code&gt;if ( $Handles.length === 1 ) {</p>

<pre><code>return false;</code></pre>

<p>} return ( to === lower || to === upper ) ? 0 :
false;&lt;/code&gt;&lt;/pre&gt;</p>

<p>&lt;p&gt;}&lt;/p&gt;</p>

<p>&lt;p&gt;// Set the handle to the new position. handle.css( options.style,
to + &amp;amp;amp;#39;%&amp;amp;amp;#39; );&lt;/p&gt;</p>

<p>&lt;p&gt;// Force proper handle stacking if (
handle.is(&amp;amp;amp;#39;:first-child&amp;amp;amp;#39;) ) {&lt;/p&gt;</p>

<p>&lt;<a href="17">pre>handle.toggleClass(Classes</a><code>, to
&amp;amp;amp;gt; 50 );</code>&lt;/pre&gt;</p>

<p>&lt;p&gt;}&lt;/p&gt;</p>

<p>&lt;p&gt;// Update locations. $&lt;a href=“n”&gt;Locations&lt;/a&gt; =
to;&lt;/p&gt;</p>

<p>&lt;p&gt;// Invert the value if this is a right-to-left slider. if (
options.dir ) {&lt;/p&gt;</p>

<p>&lt;pre&gt;<code>to = 100 - to;</code>&lt;/pre&gt;</p>

<p>&lt;p&gt;}&lt;/p&gt;</p>

<p>&lt;p&gt;// Write values to serialization Links. // Convert the value to
the correct relative representation. $($&lt;a
href=“n”&gt;Serialization&lt;/a&gt;).each(function(){&lt;/p&gt;</p>

<p>&lt;pre&gt;<code>this.write( options, to, handle.children(), $Target
);</code>&lt;/pre&gt;</p>

<p>&lt;p&gt;});&lt;/p&gt;</p>

<p>&lt;p&gt;return true;&amp;lt;/code&amp;gt;&amp;lt;/pre&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;}&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;// Delimit proposed values for handle positions.
function getPositions ( a, b, delimit ) {&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;pre&amp;gt;&amp;lt;code&amp;gt;// Add movement to current
position. var c = a + &lt;a href=“0”&gt;b&lt;/a&gt;, d = a + &lt;a
href=“1”&gt;b&lt;/a&gt;;&lt;/p&gt;</p>

<p>&lt;p&gt;// Only alter the other position on drag, // not on standard
sliding. if ( delimit ) {&lt;/p&gt;</p>

<p>&lt;pre&gt;&lt;code&gt;if ( c &amp;amp;amp;lt; 0 ) {</p>

<pre><code>d += Math.abs(c);</code></pre>

<p>} if ( d &amp;amp;amp;gt; 100 ) {</p>

<pre><code>c -= ( d - 100 );</code></pre>

<p>}</p>

<p>// Limit values to 0 and 100. return [limit©,
limit(d)];&lt;/code&gt;&lt;/pre&gt;</p>

<p>&lt;p&gt;}&lt;/p&gt;</p>

<p>&lt;p&gt;return [c,d];&amp;lt;/code&amp;gt;&amp;lt;/pre&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;}&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;// Handles movement by tapping. function jump (
handle, to, instant ) {&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;pre&amp;gt;&amp;lt;code&amp;gt;if ( !instant ) {&lt;/p&gt;</p>

<p>&lt;pre&gt;<code>// Flag the slider as it is now in a transitional state.
// Transition takes 300 ms, so re-enable the slider afterwards.
addClassFor( $Target, Classes[14], 300 );</code>&lt;/pre&gt;</p>

<p>&lt;p&gt;}&lt;/p&gt;</p>

<p>&lt;p&gt;// Move the handle to the new position. setHandle( handle, to,
false );&lt;/p&gt;</p>

<p>&lt;p&gt;fireEvents([&amp;amp;amp;#39;slide&amp;amp;amp;#39;,
&amp;amp;amp;#39;set&amp;amp;amp;#39;,
&amp;amp;amp;#39;change&amp;amp;amp;#39;]);&amp;lt;/code&amp;gt;&amp;lt;/pre&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;}&amp;amp;lt;/code&amp;amp;gt;&amp;amp;lt;/pre&amp;amp;gt;&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;&amp;amp;lt;p&amp;amp;gt;//
Events&amp;amp;lt;/p&amp;amp;gt;&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;&amp;amp;lt;pre&amp;amp;gt;&amp;amp;lt;code&amp;amp;gt;//
Handler for attaching events trough a proxy. function attach ( events,
element, callback, data ) {&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;pre&amp;gt;&amp;lt;code&amp;gt;// Add the noUiSlider
namespace to all events. events = events.replace( /s/g, namespace +
&amp;amp;amp;#39; &amp;amp;amp;#39; ) + namespace;&lt;/p&gt;</p>

<p>&lt;p&gt;// Bind a closure on the target. return element.on( events,
function( e ){&lt;/p&gt;</p>

<p>&lt;pre&gt;&lt;code&gt;// jQuery and Zepto handle unset attributes
differently. var disabled =
$Target.attr(&amp;amp;amp;#39;disabled&amp;amp;amp;#39;);</p>

<pre><code>disabled = !( disabled === undefined || disabled === null );</code></pre>

<p>// Test if there is anything that should prevent an event // from being
handled, such as a disabled state or an active //
&amp;amp;amp;#39;tap&amp;amp;amp;#39; transition. if( $Target.hasClass( <a
href="14">Classes</a> ) || disabled ) {</p>

<pre><code>return false;</code></pre>

<p>}</p>

<p>e = fixEvent(e); e.calcPoint = e.points[ options.ort ];</p>

<p>// Call the event handler with the event [ and additional data ]. callback
( e, data );&lt;/code&gt;&lt;/pre&gt;</p>

<p>&lt;p&gt;});&amp;lt;/code&amp;gt;&amp;lt;/pre&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;}&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;// Handle movement on document for handle and
range drag. function move ( event, data ) {&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;pre&amp;gt;&amp;lt;code&amp;gt;var handles = data.handles
|| $Handles, positions, state = false,&lt;/p&gt;</p>

<p>&lt;pre&gt;<code>proposal = ((event.calcPoint - data.start) * 100) /
baseSize(), h = handles[0][0] !== $Handles[0][0] ? 1 :
0;</code>&lt;/pre&gt;</p>

<p>&lt;p&gt;// Calculate relative positions for the handles. positions =
getPositions( proposal, data.positions, handles.length &amp;amp;amp;gt;
1);&lt;/p&gt;</p>

<p>&lt;p&gt;state = setHandle ( &lt;a href=“0”&gt;handles&lt;/a&gt;, &lt;a
href=“h”&gt;positions&lt;/a&gt;, handles.length === 1 );&lt;/p&gt;</p>

<p>&lt;p&gt;if ( handles.length &amp;amp;amp;gt; 1 ) {&lt;/p&gt;</p>

<p>&lt;pre&gt;<code>state = setHandle ( handles[1], positions[h?0:1], false )
|| state;</code>&lt;/pre&gt;</p>

<p>&lt;p&gt;}&lt;/p&gt;</p>

<p>&lt;p&gt;// Fire the &amp;amp;amp;#39;slide&amp;amp;amp;#39; event if any
handle moved. if ( state ) {&lt;/p&gt;</p>

<p>&lt;<a
href="&amp;amp;#39;slide&amp;amp;#39;">pre>fireEvents(</a><code>);</code>&lt;/pre&gt;</p>

<p>&lt;p&gt;}&amp;lt;/code&amp;gt;&amp;lt;/pre&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;}&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;// Unbind move events on document, call
callbacks. function end ( event ) {&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;pre&amp;gt;&amp;lt;code&amp;gt;// The handle is no longer
active, so remove the class. $(&amp;amp;amp;#39;.&amp;amp;amp;#39; + &lt;a
href=“15”&gt;Classes&lt;/a&gt;).&lt;a
href=“15”&gt;removeClass(Classes&lt;/a&gt;);&lt;/p&gt;</p>

<p>&lt;p&gt;// Remove cursor styles and text-selection events bound to the
body. if ( event.cursor ) {&lt;/p&gt;</p>

<p>&lt;pre&gt;<code>$(&amp;amp;amp;#39;body&amp;amp;amp;#39;).css(&amp;amp;amp;#39;cursor&amp;amp;amp;#39;,
&amp;amp;amp;#39;&amp;amp;amp;#39;).off( namespace );</code>&lt;/pre&gt;</p>

<p>&lt;p&gt;}&lt;/p&gt;</p>

<p>&lt;p&gt;// Unbind the move and end events, which are added on
&amp;amp;amp;#39;start&amp;amp;amp;#39;. doc.off( namespace );&lt;/p&gt;</p>

<p>&lt;p&gt;// Remove dragging class. $&lt;a
href=“12”&gt;Target.removeClass(Classes&lt;/a&gt;);&lt;/p&gt;</p>

<p>&lt;p&gt;// Fire the change and set events.
fireEvents([&amp;amp;amp;#39;set&amp;amp;amp;#39;,
&amp;amp;amp;#39;change&amp;amp;amp;#39;]);&amp;lt;/code&amp;gt;&amp;lt;/pre&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;}&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;// Bind move events on document. function start (
event, data ) {&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;pre&amp;gt;&amp;lt;code&amp;gt;// Mark the handle as
&amp;amp;amp;#39;active&amp;amp;amp;#39; so it can be styled. if(
data.handles.length === 1 ) {&lt;/p&gt;</p>

<p>&lt;<a
href="0">pre>data.handles</a><code>.children().addClass(Classes[15]);</code>&lt;/pre&gt;</p>

<p>&lt;p&gt;}&lt;/p&gt;</p>

<p>&lt;p&gt;// A drag should never propagate up to the
&amp;amp;amp;#39;tap&amp;amp;amp;#39; event.
event.stopPropagation();&lt;/p&gt;</p>

<p>&lt;p&gt;// Attach the move event. attach ( actions.move, doc, move,
{&lt;/p&gt;</p>

<p>&lt;pre&gt;&lt;code&gt;start: event.calcPoint, handles: data.handles,
positions: [</p>

<pre><code>$Locations[0],
$Locations[$Handles.length - 1]</code></pre>

<p>]&lt;/code&gt;&lt;/pre&gt;</p>

<p>&lt;p&gt;});&lt;/p&gt;</p>

<p>&lt;p&gt;// Unbind all movement when the drag ends. attach ( actions.end,
doc, end, null );&lt;/p&gt;</p>

<p>&lt;p&gt;// Text selection isn&amp;amp;amp;#39;t an issue on touch devices,
// so adding cursor styles can be skipped. if ( event.cursor ) {&lt;/p&gt;</p>

<p>&lt;pre&gt;&lt;code&gt;// Prevent the &amp;amp;amp;#39;I&amp;amp;amp;#39;
cursor and extend the range-drag cursor.
$(&amp;amp;amp;#39;body&amp;amp;amp;#39;).css(&amp;amp;amp;#39;cursor&amp;amp;amp;#39;,
$(event.target).css(&amp;amp;amp;#39;cursor&amp;amp;amp;#39;));</p>

<p>// Mark the target with a dragging state. if ( $Handles.length
&amp;amp;amp;gt; 1 ) {</p>

<pre><code>$Target.addClass(Classes[12]);</code></pre>

<p>}</p>

<p>// Prevent text selection when dragging the handles.
$(&amp;amp;amp;#39;body&amp;amp;amp;#39;).on(&amp;amp;amp;#39;selectstart&amp;amp;amp;#39;
+ namespace, false);&lt;/code&gt;&lt;/pre&gt;</p>

<p>&lt;p&gt;}&amp;lt;/code&amp;gt;&amp;lt;/pre&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;}&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;// Move closest handle to tapped location.
function tap ( event ) {&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;pre&amp;gt;&amp;lt;code&amp;gt;var location =
event.calcPoint, total = 0, to;&lt;/p&gt;</p>

<p>&lt;p&gt;// The tap event shouldn&amp;amp;amp;#39;t propagate up and cause
&amp;amp;amp;#39;edge&amp;amp;amp;#39; to run.
event.stopPropagation();&lt;/p&gt;</p>

<p>&lt;p&gt;// Add up the handle offsets. $.each( $Handles,
function(){&lt;/p&gt;</p>

<p>&lt;pre&gt;<code>total += this.offset()[ options.style
];</code>&lt;/pre&gt;</p>

<p>&lt;p&gt;});&lt;/p&gt;</p>

<p>&lt;p&gt;// Find the handle closest to the tapped position. total = (
location &amp;amp;amp;lt; total/2 || $Handles.length === 1 ) ? 0 :
1;&lt;/p&gt;</p>

<p>&lt;p&gt;location -= $Base.offset()[ options.style ];&lt;/p&gt;</p>

<p>&lt;p&gt;// Calculate the new position. to = ( location * 100 ) /
baseSize();&lt;/p&gt;</p>

<p>&lt;p&gt;// Find the closest handle and calculate the tapped point. // The
set handle to the new position. jump( $&lt;a
href=“total”&gt;Handles&lt;/a&gt;, to, options.events.snap );&lt;/p&gt;</p>

<p>&lt;p&gt;if ( options.events.snap ) {&lt;/p&gt;</p>

<p>&lt;pre&gt;<code>start(event, { handles: [$Handles[total]]
});</code>&lt;/pre&gt;</p>

<p>&lt;p&gt;}&amp;lt;/code&amp;gt;&amp;lt;/pre&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;}&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;// Move handle to edges when target gets tapped.
function edge ( event ) {&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;pre&amp;gt;&amp;lt;code&amp;gt;var i = event.calcPoint
&amp;amp;amp;lt; $Base.offset()[ options.style ],&lt;/p&gt;</p>

<p>&lt;pre&gt;<code>to = i ? 0 : 100;</code>&lt;/pre&gt;</p>

<p>&lt;p&gt;i = i ? 0 : $Handles.length - 1;&lt;/p&gt;</p>

<p>&lt;p&gt;jump( $&lt;a href=“i”&gt;Handles&lt;/a&gt;, to, false
);&amp;lt;/code&amp;gt;&amp;lt;/pre&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;}&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;// Attach events to several slider parts.
function events ( behaviour ) {&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;pre&amp;gt;&amp;lt;code&amp;gt;var i, drag;&lt;/p&gt;</p>

<p>&lt;p&gt;// Attach the standard drag event to the handles. if (
!behaviour.fixed ) {&lt;/p&gt;</p>

<p>&lt;pre&gt;&lt;code&gt;for ( i = 0; i &amp;amp;amp;lt; $Handles.length; i++
) {</p>

<pre><code>// These events are only bound to the visual handle
// element, not the &amp;amp;amp;#39;real&amp;amp;amp;#39; origin element.
attach ( actions.start, $Handles[i].children(), start, {
        handles: [ $Handles[i] ]
});</code></pre>

<p>}&lt;/code&gt;&lt;/pre&gt;</p>

<p>&lt;p&gt;}&lt;/p&gt;</p>

<p>&lt;p&gt;// Attach the tap event to the slider base. if ( behaviour.tap )
{&lt;/p&gt;</p>

<p>&lt;pre&gt;&lt;code&gt;attach ( actions.start, $Base, tap, {</p>

<pre><code>handles: $Handles</code></pre>

<p>});&lt;/code&gt;&lt;/pre&gt;</p>

<p>&lt;p&gt;}&lt;/p&gt;</p>

<p>&lt;p&gt;// Extend tapping behaviour to target if ( behaviour.extend )
{&lt;/p&gt;</p>

<p>&lt;pre&gt;&lt;code&gt;$Target.addClass( <a href="16">Classes</a> );</p>

<p>if ( behaviour.tap ) {</p>

<pre><code>attach ( actions.start, $Target, edge, {
        handles: $Handles
});</code></pre>

<p>}&lt;/code&gt;&lt;/pre&gt;</p>

<p>&lt;p&gt;}&lt;/p&gt;</p>

<p>&lt;p&gt;// Make the range dragable. if ( behaviour.drag ){&lt;/p&gt;</p>

<p>&lt;pre&gt;&lt;code&gt;drag = $Base.find(
&amp;amp;amp;#39;.&amp;amp;amp;#39; + <a href="7">Classes</a> ).addClass(
<a href="10">Classes</a> );</p>

<p>// When the range is fixed, the entire range can // be dragged by the
handles. The handle in the first // origin will propagate the start event
upward, // but it needs to be bound manually on the other. if (
behaviour.fixed ) {</p>

<pre><code>drag = drag.add($Base.children().not( drag ).children());</code></pre>

<p>}</p>

<p>attach ( actions.start, drag, start, {</p>

<pre><code>handles: $Handles</code></pre>

<p>});&lt;/code&gt;&lt;/pre&gt;</p>

<p>&lt;p&gt;}&amp;lt;/code&amp;gt;&amp;lt;/pre&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;}&amp;amp;lt;/code&amp;amp;gt;&amp;amp;lt;/pre&amp;amp;gt;&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;&amp;amp;lt;p&amp;amp;gt;// Initialize
slider&amp;amp;lt;/p&amp;amp;gt;&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;&amp;amp;lt;pre&amp;amp;gt;&amp;amp;lt;code&amp;amp;gt;//
Throw an error if the slider was already initialized. if (
!$Target.is(&amp;amp;amp;#39;:empty&amp;amp;amp;#39;) )
{&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;pre&amp;gt;<code>throw new Error(&amp;amp;amp;#39;Slider
was already
initialized.&amp;amp;amp;#39;);</code>&amp;lt;/pre&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;}&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;// Create the base element, initialise HTML and
set classes. // Add handles and links. $Base = addSlider( options, $Target
); $Handles = addHandles( options, $Base ); $Serialization = addLinks(
options, $Handles );&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;// Set the connect classes. addConnection (
options.connect, $Target, $Handles );&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;// Attach user events. events( options.events
);&amp;amp;lt;/code&amp;amp;gt;&amp;amp;lt;/pre&amp;amp;gt;&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;&amp;amp;lt;p&amp;amp;gt;//
Methods&amp;amp;lt;/p&amp;amp;gt;&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;&amp;amp;lt;pre&amp;amp;gt;&amp;amp;lt;code&amp;amp;gt;//
Set the slider value. target.vSet = function ( values, callback, link,
update, animate ){&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;pre&amp;gt;&amp;lt;code&amp;gt;var i, to;&lt;/p&gt;</p>

<p>&lt;p&gt;// The RTL settings is implemented by reversing the front-end, //
internal mechanisms are the same. if ( options.dir
&amp;amp;amp;amp;&amp;amp;amp;amp; options.handles &amp;amp;amp;gt; 1 )
{&lt;/p&gt;</p>

<p>&lt;pre&gt;<code>values.reverse();</code>&lt;/pre&gt;</p>

<p>&lt;p&gt;}&lt;/p&gt;</p>

<p>&lt;p&gt;// Animation is optional. if ( animate ) {&lt;/p&gt;</p>

<p>&lt;pre&gt;<code>addClassFor( $Target, Classes[14], 300
);</code>&lt;/pre&gt;</p>

<p>&lt;p&gt;}&lt;/p&gt;</p>

<p>&lt;p&gt;// If there are multiple handles to be set run the setting //
mechanism twice for the first handle, to make sure it // can be bounced of
the second one properly. for ( i = 0; i &amp;amp;amp;lt; ( $Handles.length
&amp;amp;amp;gt; 1 ? 3 : 1 ); i++ ) {&lt;/p&gt;</p>

<p>&lt;pre&gt;&lt;code&gt;to = link || $<a href="i%2">Serialization</a>[0]; to
= to.valueOf( <a href="i%2">values</a> );</p>

<p>if ( to === false ) {</p>

<pre><code>continue;</code></pre>

<p>}</p>

<p>// Calculate the new handle position to = toStepping( options, to );</p>

<p>// Invert the value if this is a right-to-left slider. if ( options.dir ) {</p>

<pre><code>to = 100 - to;</code></pre>

<p>}</p>

<p>// Force delimitation. if ( setHandle( $<a href="i%2">Handles</a>, to, true
) === true ) {</p>

<pre><code>continue;</code></pre>

<p>}</p>

<p>// Reset the input if it doesn&amp;amp;amp;#39;t match the slider. $($<a
href="i%2">Serialization</a>).each(function(){</p>

<pre><code>this.write(
        options,
        $Locations[i%2],
        $Handles[i%2].children(),
        $Target,
        update
);</code></pre>

<p>});&lt;/code&gt;&lt;/pre&gt;</p>

<p>&lt;p&gt;}&lt;/p&gt;</p>

<p>&lt;p&gt;// Optionally fire the &amp;amp;amp;#39;set&amp;amp;amp;#39;
event. if( callback</p>

<h3 id="label-true+%29+%7B%3C%2Fp%3E">true ) {&lt;/p&gt;</h3>

<p>&lt;<a
href="&amp;amp;#39;set&amp;amp;#39;">pre>fireEvents(</a><code>);</code>&lt;/pre&gt;</p>

<p>&lt;p&gt;}&lt;/p&gt;</p>

<p>&lt;p&gt;return this;&amp;lt;/code&amp;gt;&amp;lt;/pre&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;};&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;// Get the slider value. target.vGet = function (
){&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;pre&amp;gt;&amp;lt;code&amp;gt;var i, retour =
[];&lt;/p&gt;</p>

<p>&lt;p&gt;// Get the value from all handles. for ( i = 0; i &amp;amp;amp;lt;
options.handles; i++ ){&lt;/p&gt;</p>

<p>&lt;<a href="i">pre>retour</a><code> =
$Serialization[i][0].saved;</code>&lt;/pre&gt;</p>

<p>&lt;p&gt;}&lt;/p&gt;</p>

<p>&lt;p&gt;// If only one handle is used, return a single value. if (
retour.length</p>

<h3 id="label-1+%29%7B%3C%2Fp%3E">1 ){&lt;/p&gt;</h3>

<p>&lt;pre&gt;<code>return retour[0];</code>&lt;/pre&gt;</p>

<p>&lt;p&gt;}&lt;/p&gt;</p>

<p>&lt;p&gt;if ( options.dir &amp;amp;amp;amp;&amp;amp;amp;amp;
options.handles &amp;amp;amp;gt; 1 ) {&lt;/p&gt;</p>

<p>&lt;pre&gt;<code>return retour.reverse();</code>&lt;/pre&gt;</p>

<p>&lt;p&gt;}&lt;/p&gt;</p>

<p>&lt;p&gt;return retour;&amp;lt;/code&amp;gt;&amp;lt;/pre&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;};&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;// Destroy the slider and unbind all events.
target.destroy = function ( ){&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;pre&amp;gt;&amp;lt;code&amp;gt;// Loop all linked
serialization objects and unbind all // events in the noUiSlider namespace.
$.each($Serialization, function(){&lt;/p&gt;</p>

<p>&lt;pre&gt;&lt;code&gt;$.each(this, function(){</p>

<pre><code>// Won&amp;amp;amp;#39;t remove &amp;amp;amp;#39;change&amp;amp;amp;#39; when bound implicitly.
if ( this.target ) {
        this.target.off( namespace );
}</code></pre>

<p>});&lt;/code&gt;&lt;/pre&gt;</p>

<p>&lt;p&gt;});&lt;/p&gt;</p>

<p>&lt;p&gt;// Unbind events on the slider, remove all classes and child
elements. $(this).off(namespace)&lt;/p&gt;</p>

<p>&lt;pre&gt;<code>.removeClass(Classes.join(&amp;amp;amp;#39;
&amp;amp;amp;#39;)) .empty();</code>&lt;/pre&gt;</p>

<p>&lt;p&gt;// Return the original options from the closure. return
originalOptions;&amp;lt;/code&amp;gt;&amp;lt;/pre&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;};&amp;amp;lt;/code&amp;amp;gt;&amp;amp;lt;/pre&amp;amp;gt;&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;&amp;amp;lt;p&amp;amp;gt;// Value
setting&amp;amp;lt;/p&amp;amp;gt;&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;&amp;amp;lt;pre&amp;amp;gt;<code>// Use the
public value method to set the start values. $Target.val( options.start
);</code>&amp;amp;lt;/pre&amp;amp;gt;&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;&amp;amp;lt;p&amp;amp;gt;}&amp;amp;lt;/p&amp;amp;gt;&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;&amp;amp;lt;p&amp;amp;gt;// Access
points&amp;amp;lt;/p&amp;amp;gt;&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;&amp;amp;lt;pre&amp;amp;gt;&amp;amp;lt;code&amp;amp;gt;//
Run the standard initializer function initialize ( originalOptions )
{&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;pre&amp;gt;&amp;lt;code&amp;gt;// Throw error if group is
empty. if ( !this.length ){&lt;/p&gt;</p>

<p>&lt;pre&gt;<code>throwError(&amp;amp;amp;quot;Can&amp;amp;amp;#39;t
initialize slider on empty
selection.&amp;amp;amp;quot;);</code>&lt;/pre&gt;</p>

<p>&lt;p&gt;}&lt;/p&gt;</p>

<p>&lt;p&gt;// Test the options once, not for every slider. var options =
test( originalOptions, this );&lt;/p&gt;</p>

<p>&lt;p&gt;// Loop all items, and provide a new closed-scope environment.
return this.each(function(){&lt;/p&gt;</p>

<p>&lt;pre&gt;<code>closure(this, options,
originalOptions);</code>&lt;/pre&gt;</p>

<p>&lt;p&gt;});&amp;lt;/code&amp;gt;&amp;lt;/pre&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;}&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;// Destroy the slider, then re-enter
initialization. function rebuild ( options ) {&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;pre&amp;gt;&amp;lt;code&amp;gt;return
this.each(function(){&lt;/p&gt;</p>

<p>&lt;pre&gt;&lt;code&gt;// Get the current values from the slider, //
including the initialization options. var values = $(this).val(),</p>

<pre><code>originalOptions = this.destroy(),

// Extend the previous options with the newly provided ones.
newOptions = $.extend( {}, originalOptions, options );</code></pre>

<p>// Run the standard initializer. $(this).noUiSlider( newOptions );</p>

<p>// If the start option hasn&amp;amp;amp;#39;t changed, // reset the
previous values. if ( originalOptions.start === newOptions.start ) {</p>

<pre><code>$(this).val(values);</code></pre>

<p>}&lt;/code&gt;&lt;/pre&gt;</p>

<p>&lt;p&gt;});&amp;lt;/code&amp;gt;&amp;lt;/pre&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;}&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;// Expose serialization constructor. /** @expose
*/ $.noUiSlider = { &amp;amp;amp;#39;Link&amp;amp;amp;#39;: Link
};&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;// Extend jQuery/Zepto with the noUiSlider
method. /** @expose */ $.fn.noUiSlider = function ( options, re )
{&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;pre&amp;gt;<code>return ( re ? rebuild : initialize
).call(this, options);</code>&amp;lt;/pre&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;};&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;$.fn.val = function ( )
{&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;pre&amp;gt;&amp;lt;code&amp;gt;// Convert the function
arguments to an array. var args = Array.prototype.slice.call( arguments, 0
),&lt;/p&gt;</p>

<p>&lt;pre&gt;<code>set, link, update, animate;</code>&lt;/pre&gt;</p>

<p>&lt;p&gt;// Test if there are arguments, and if not, call the
&amp;amp;amp;#39;get&amp;amp;amp;#39; method. if ( !args.length )
{&lt;/p&gt;</p>

<p>&lt;pre&gt;&lt;code&gt;// Determine whether to use the native val method.
if ( <a href="0">this.hasClass(Classes</a>) ) {</p>

<pre><code>return this[0].vGet();</code></pre>

<p>}</p>

<p>return $val.apply( this );&lt;/code&gt;&lt;/pre&gt;</p>

<p>&lt;p&gt;}&lt;/p&gt;</p>

<p>&lt;p&gt;// Extract modifiers for value method. if ( typeof &lt;a
href=“1”&gt;args&lt;/a&gt; === &amp;amp;amp;#39;object&amp;amp;amp;#39; )
{&lt;/p&gt;</p>

<p>&lt;pre&gt;<code>set = args[1][&amp;amp;amp;#39;set&amp;amp;amp;#39;]; link
= args[1][&amp;amp;amp;#39;link&amp;amp;amp;#39;]; update =
args[1][&amp;amp;amp;#39;update&amp;amp;amp;#39;]; animate =
args[1][&amp;amp;amp;#39;animate&amp;amp;amp;#39;];</code>&lt;/pre&gt;</p>

<p>&lt;p&gt;// Support the &amp;amp;amp;#39;true&amp;amp;amp;#39; option. }
else if ( &lt;a href=“1”&gt;args&lt;/a&gt; === true ) {&lt;/p&gt;</p>

<p>&lt;pre&gt;<code>set = true;</code>&lt;/pre&gt;</p>

<p>&lt;p&gt;}&lt;/p&gt;</p>

<p>&lt;p&gt;// Loop all individual items, and handle setting appropriately.
return this.each(function(){&lt;/p&gt;</p>

<p>&lt;pre&gt;&lt;code&gt;if ( $(<a href="0">this).hasClass(Classes</a>) ) {</p>

<pre><code>this.vSet( asArray(args[0]), set, link, update, animate );</code></pre>

<p>} else {</p>

<pre><code>$val.apply( $(this), args );</code></pre>

<p>}&lt;/code&gt;&lt;/pre&gt;</p>

<p>&lt;p&gt;});&amp;lt;/code&amp;gt;&amp;lt;/pre&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;};&amp;amp;lt;/code&amp;amp;gt;&amp;amp;lt;/pre&amp;amp;gt;&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;&amp;amp;lt;p&amp;amp;gt;}( &amp;amp;lt;a
href=“&amp;amp;#39;jQuery&amp;amp;#39;”&amp;amp;gt;window&amp;amp;lt;/a&amp;amp;gt;
|| &amp;amp;lt;a
href=“&amp;amp;#39;Zepto&amp;amp;#39;”&amp;amp;gt;window&amp;amp;lt;/a&amp;amp;gt;
));&amp;amp;lt;/p&amp;amp;gt;&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;pre&amp;gt;&amp;lt;code&amp;gt; 
&amp;amp;lt;/div&amp;amp;gt;&lt;/p&gt;</p>

<p>&lt;pre&gt;&lt;code&gt;&amp;amp;lt;!– Methods –&amp;amp;gt;</p>

<pre><code>&amp;amp;lt;/div&amp;amp;gt;</code></pre>

<p>&amp;amp;lt;/div&amp;amp;gt;&lt;/code&gt;&lt;/pre&gt;</p>

<p>&lt;p&gt;&amp;amp;lt;/body&amp;amp;gt;&amp;lt;/code&amp;gt;&amp;lt;/pre&amp;gt;&lt;/p&gt;</p>

<p>&lt;p&gt;&amp;lt;p&amp;gt;&amp;amp;lt;/html&amp;amp;gt;&amp;lt;/p&amp;gt;&lt;/p&gt;</p>

<p>&lt;pre&gt;&lt;code&gt;  &amp;lt;/div&amp;gt;</p>

<pre><code>&amp;lt;!-- Methods --&amp;gt;
          &amp;lt;/div&amp;gt;

&amp;lt;/div&amp;gt;</code></pre>

<p>&amp;lt;/body&amp;gt;&lt;/code&gt;&lt;/pre&gt;</p>

<p>&lt;p&gt;&amp;lt;/html&amp;gt;&lt;/p&gt;</p>

<pre><code>  &lt;/div&gt;

  &lt;!-- Methods --&gt;
            &lt;/div&gt;

  &lt;/div&gt;
&lt;/body&gt;</code></pre>

<p>&lt;/html&gt;</p>

    </div>
  


  


  
  


  


  

  



  

    

    

    


    


    <!-- Methods -->
              </div>

    </div>
  </body>
</html>
